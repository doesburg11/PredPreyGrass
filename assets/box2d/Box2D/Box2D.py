# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _Box2D
else:
    import _Box2D

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _Box2D.SWIG_PyInstanceMethod_New
_swig_new_static_method = _Box2D.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref


def _dir_filter(self):
    """
    Using introspection, mimic dir() by adding up all of the __dicts__
    for the current class and all base classes (type(self).__mro__ returns
    all of the classes that make it up)
    Basically filters by:
        __x__ OK
        __x bad
        _classname bad
    """

    def check(s):
        if s.startswith('__'):
            if s.endswith('__'):
                return True
            else:
                return False
        else:
            for typename in typenames:
                if typename in s:
                    return False
            return True

    keys = sum([list(c.__dict__.keys()) for c in type(self).__mro__],[])
    keys += list(self.__dict__.keys())
    typenames = ["_%s" % c.__name__ for c in type(self).__mro__]
    ret = [s for s in list(set(keys)) if check(s)]
    ret.sort()
    return ret



def _init_kwargs(self, **kwargs):
    cls = self.__class__
    for key, value in kwargs.items():
        try:
            getattr(cls, key)
        except AttributeError:
            raise AttributeError('Invalid keyword argument "%s" for %s' % (key, cls))

        try:
            setattr(self, key, value)
        except Exception as ex:
            raise ex.__class__('Failed on kwargs for %s.%s: %s' \
                        % (self.__class__.__name__, key, ex))

def _init_jointdef_kwargs(self, bodyA=None, bodyB=None, **kwargs):
    if bodyA is not None or bodyB is not None:
# Make sure that bodyA and bodyB are defined before the rest
        _init_kwargs(self, bodyA=bodyA, bodyB=bodyB)

    _init_kwargs(self, **kwargs)


_repr_attrs = {'b2AABB': ['center', 'extents', 'lowerBound', 'perimeter', 'upperBound', 
                          'valid', ],
               'b2Body': ['active', 'angle', 'angularDamping', 'angularVelocity', 'awake', 
                          'bullet', 'contacts', 'fixedRotation', 'fixtures', 
                          'inertia', 'joints', 'linearDamping', 'linearVelocity', 
                          'localCenter', 'mass', 'massData', 'position', 
                          'sleepingAllowed', 'transform', 'type', 'userData', 
                          'worldCenter', ],
               'b2BodyDef': ['active', 'allowSleep', 'angle', 'angularDamping', 'angularVelocity', 
                             'awake', 'bullet', 'fixedRotation', 'fixtures', 
                             'inertiaScale', 'linearDamping', 'linearVelocity', 'position', 
                             'shapeFixture', 'shapes', 'type', 'userData', 
                             ],
               'b2BroadPhase': ['proxyCount', ],
               'b2CircleShape': ['childCount', 'pos', 'radius', 'type', ],
               'b2ClipVertex': ['id', 'v', ],
               'b2Color': ['b', 'bytes', 'g', 'list', 'r', 
                           ],
               'b2Contact': ['childIndexA', 'childIndexB', 'enabled', 'fixtureA', 'fixtureB', 
                             'manifold', 'touching', 'worldManifold', ],
               'b2ContactEdge': ['contact', 'other', ],
               'b2ContactFeature': ['indexA', 'indexB', 'typeA', 'typeB', ],
               'b2ContactID': ['cf', 'key', ],
               'b2ContactImpulse': ['normalImpulses', 'tangentImpulses', ],
               'b2ContactManager': ['allocator', 'broadPhase', 'contactCount', 'contactFilter', 'contactList', 
                                    'contactListener', ],
               'b2ContactPoint': ['fixtureA', 'fixtureB', 'normal', 'position', 'state', 
                                  ],
               'b2DistanceInput': ['proxyA', 'proxyB', 'transformA', 'transformB', 'useRadii', 
                                   ],
               'b2DistanceJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                                   'dampingRatio', 'frequency', 'length', 'type', 
                                   'userData', ],
               'b2DistanceJointDef': ['anchorA', 'anchorB', 'bodyA', 'bodyB', 'collideConnected', 
                                      'dampingRatio', 'frequencyHz', 'length', 'localAnchorA', 
                                      'localAnchorB', 'type', 'userData', ],
               'b2DistanceOutput': ['distance', 'iterations', 'pointA', 'pointB', ],
               'b2DistanceProxy': ['m_buffer', 'shape', 'vertices', ],
               'b2Draw': ['flags', ],
               'b2DrawExtended': ['center', 'convertVertices', 'flags', 'flipX', 'flipY', 
                                  'offset', 'screenSize', 'zoom', ],
               'b2EdgeShape': ['all_vertices', 'childCount', 'hasVertex0', 'hasVertex3', 'radius', 
                               'type', 'vertex0', 'vertex1', 'vertex2', 
                               'vertex3', 'vertexCount', 'vertices', ],
               'b2Filter': ['categoryBits', 'groupIndex', 'maskBits', ],
               'b2Fixture': ['body', 'density', 'filterData', 'friction', 'massData', 
                             'restitution', 'sensor', 'shape', 'type', 
                             'userData', ],
               'b2FixtureDef': ['categoryBits', 'density', 'filter', 'friction', 'groupIndex', 
                                'isSensor', 'maskBits', 'restitution', 'shape', 
                                'userData', ],
               'b2FixtureProxy': ['aabb', 'childIndex', 'fixture', 'proxyId', ],
               'b2FrictionJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                                   'maxForce', 'maxTorque', 'type', 'userData', 
                                   ],
               'b2FrictionJointDef': ['anchor', 'bodyA', 'bodyB', 'collideConnected', 'localAnchorA', 
                                      'localAnchorB', 'maxForce', 'maxTorque', 'type', 
                                      'userData', ],
               'b2GearJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                               'ratio', 'type', 'userData', ],
               'b2GearJointDef': ['bodyA', 'bodyB', 'collideConnected', 'joint1', 'joint2', 
                                  'ratio', 'type', 'userData', ],
               'b2Jacobian': ['angularA', 'angularB', 'linearA', 'linearB', ],
               'b2Joint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                           'type', 'userData', ],
               'b2JointDef': ['bodyA', 'bodyB', 'collideConnected', 'type', 'userData', 
                              ],
               'b2JointEdge': ['joint', 'other', ],
               'b2WheelJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                                'maxMotorTorque', 'motorEnabled', 'motorSpeed', 'speed', 
                                'springDampingRatio', 'springFrequencyHz', 'translation', 'type', 
                                'userData', ],
               'b2WheelJointDef': ['anchor', 'axis', 'bodyA', 'bodyB', 'collideConnected', 
                                   'dampingRatio', 'enableMotor', 'frequencyHz', 'localAnchorA', 
                                   'localAnchorB', 'localAxisA', 'maxMotorTorque', 'motorSpeed', 
                                   'type', 'userData', ],
               'b2ChainShape': ['childCount', 'edges', 'radius', 'type', 'vertexCount', 
                                'vertices', ],
               'b2Manifold': ['localNormal', 'localPoint', 'pointCount', 'points', 'type_', 
                              ],
               'b2ManifoldPoint': ['id', 'isNew', 'localPoint', 'normalImpulse', 'tangentImpulse', 
                                   ],
               'b2MassData': ['I', 'center', 'mass', ],
               'b2Mat22': ['angle', 'col1', 'col2', 'inverse', ],
               'b2Mat33': ['col1', 'col2', 'col3', ],
               'b2MouseJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                                'dampingRatio', 'frequency', 'maxForce', 'target', 
                                'type', 'userData', ],
               'b2MouseJointDef': ['bodyA', 'bodyB', 'collideConnected', 'dampingRatio', 'frequencyHz', 
                                   'maxForce', 'target', 'type', 'userData', 
                                   ],
               'b2Pair': ['proxyIdA', 'proxyIdB', ],
               'b2PolygonShape': ['box', 'centroid', 'childCount', 'normals', 'radius', 
                                  'type', 'valid', 'vertexCount', 'vertices', 
                                  ],
               'b2PrismaticJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                                    'limitEnabled', 'limits', 'lowerLimit', 'maxMotorForce', 
                                    'motorEnabled', 'motorSpeed', 'speed', 'translation', 
                                    'type', 'upperLimit', 'userData', ],
               'b2PrismaticJointDef': ['anchor', 'axis', 'bodyA', 'bodyB', 'collideConnected', 
                                       'enableLimit', 'enableMotor', 'localAnchorA', 'localAnchorB', 
                                       'localAxis1', 'lowerTranslation', 'maxMotorForce', 'motorSpeed', 
                                       'referenceAngle', 'type', 'upperTranslation', 'userData', 
                                       ],
               'b2PulleyJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                                 'groundAnchorA', 'groundAnchorB', 'length1', 'length2', 
                                 'ratio', 'type', 'userData', ],
               'b2PulleyJointDef': ['anchorA', 'anchorB', 'bodyA', 'bodyB', 'collideConnected', 
                                    'groundAnchorA', 'groundAnchorB', 'lengthA', 'lengthB', 
                                    'localAnchorA', 'localAnchorB', 'maxLengthA', 'maxLengthB', 
                                    'ratio', 'type', 'userData', ],
               'b2RayCastInput': ['maxFraction', 'p1', 'p2', ],
               'b2RayCastOutput': ['fraction', 'normal', ],
               'b2RevoluteJoint': ['active', 'anchorA', 'anchorB', 'angle', 'bodyA', 
                                   'bodyB', 'limitEnabled', 'limits', 'lowerLimit', 
                                   'maxMotorTorque', 'motorEnabled', 'motorSpeed', 'speed', 
                                   'type', 'upperLimit', 'userData', ],
               'b2RevoluteJointDef': ['anchor', 'bodyA', 'bodyB', 'collideConnected', 'enableLimit', 
                                      'enableMotor', 'localAnchorA', 'localAnchorB', 'lowerAngle', 
                                      'maxMotorTorque', 'motorSpeed', 'referenceAngle', 'type', 
                                      'upperAngle', 'userData', ],
               'b2RopeJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                               'limitState', 'maxLength', 'type', 'userData', 
                               ],
               'b2RopeJointDef': ['anchorA', 'anchorB', 'bodyA', 'bodyB', 'collideConnected', 
                                  'localAnchorA', 'localAnchorB', 'maxLength', 'type', 
                                  'userData', ],
               'b2Shape': ['childCount', 'radius', 'type', ],
               'b2Sweep': ['a', 'a0', 'alpha0', 'c', 'c0', 
                           'localCenter', ],
               'b2TOIInput': ['proxyA', 'proxyB', 'sweepA', 'sweepB', 'tMax', 
                              ],
               'b2TOIOutput': ['state', 't', ],
               'b2Transform': ['R', 'angle', 'position', ],
               'b2Vec2': ['length', 'lengthSquared', 'skew', 'tuple', 'valid', 
                          'x', 'y', ],
               'b2Vec3': ['length', 'lengthSquared', 'tuple', 'valid', 'x', 
                          'y', 'z', ],
               'b2Version': ['major', 'minor', 'revision', ],
               'b2WeldJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                               'type', 'userData', ],
               'b2WeldJointDef': ['anchor', 'bodyA', 'bodyB', 'collideConnected', 'localAnchorA', 
                                  'localAnchorB', 'referenceAngle', 'type', 'userData', 
                                  ],
               'b2World': ['autoClearForces', 'bodies', 'bodyCount', 'contactCount', 'contactFilter', 
                           'contactListener', 'contactManager', 'contacts', 'continuousPhysics', 
                           'destructionListener', 'gravity', 'jointCount', 'joints', 
                           'locked', 'proxyCount', 'renderer', 'subStepping', 
                           'warmStarting', ],
               'b2WorldManifold': ['normal', 'points', ],
               }

MAX_REPR_DEPTH = 4
MAX_REPR_STR_LEN = 250
MAX_REPR_SUB_LINES = 10
REPR_INDENT = 4

_repr_state = {}
def _format_repr(obj):
    """
    Dynamically creates the object representation string for `obj`.

    Attributes found in _repr_attrs[class_name] will be included.
    """

    global _repr_state
    if 'spaces' not in _repr_state:
        _repr_state['spaces'] = 0

    if 'depth' not in _repr_state:
        _repr_state['depth'] = 1
    else:
        _repr_state['depth'] += 1

    if _repr_state['depth'] > MAX_REPR_DEPTH:
        _repr_state['depth'] -= 1
        return '%s(max recursion depth hit)' % (' ' * _repr_state['spaces'])

    class_line = '%s(' % (obj.__class__.__name__, )

    orig_spaces = _repr_state['spaces']

    ret = []

    props = _repr_attrs.get(obj.__class__.__name__, [])

    try:
        prop_spacing = _repr_state['spaces'] + len(class_line.lstrip())
        separator = '\n' + ' ' * prop_spacing

        for prop in props:
            _repr_state['spaces'] = len(prop) + 1
            try:
                s = repr(getattr(obj, prop))
            except Exception as ex:
                s = '(repr: %s)' % ex

            lines = s.split('\n')
            if len(lines) > MAX_REPR_SUB_LINES:
                length_ = 0
                for i, line_ in enumerate(lines[:MAX_REPR_SUB_LINES]):
                    length_ += len(line_)
                    if length_ > MAX_REPR_STR_LEN:
                        ending_delim = []
                        for j in s[::-1]:
                            if j in ')]}':
                                ending_delim.insert(0, j)
                            else:
                                break

                        ret[-1] = '%s...  %s' % (ret[-1], ''.join(ending_delim))
                        break

                    if i == 0:
                        ret.append('%s=%s' % (prop, line_))
                    else:
                        ret.append(line_) 
            else:
                ret.append('%s=%s' % (prop, lines[0].lstrip()))
                if len(lines) > 1:
                    ret.extend(lines[1:])

            ret[-1] += ','

    finally:
        _repr_state['depth'] -= 1
        _repr_state['spaces'] = orig_spaces

    if 1<= len(ret) <= 3:
# Closing parenthesis on same line
        ret[-1] += ')'
        return ''.join(ret)

    else:
# Closing parenthesis on next line
        ret.append(')')
        return '%s%s' % (class_line, separator.join(ret))

__jointeq = _Box2D.__jointeq
__bodyeq = _Box2D.__bodyeq
__shapeeq = _Box2D.__shapeeq
__fixtureeq = _Box2D.__fixtureeq
__b2ComputeCentroid = _Box2D.__b2ComputeCentroid
b2CheckVertices = _Box2D.b2CheckVertices
b2CheckPolygon = _Box2D.b2CheckPolygon
RAND_LIMIT = _Box2D.RAND_LIMIT

b2Random = _Box2D.b2Random

b2_epsilon = 1.192092896e-07

class _indexable_generator(list):
    def __init__(self, iter):
        list.__init__(self)
        self.iter=iter
        self.__full=False
    def __len__(self):
        self.__fill_list__()
        return super(_indexable_generator, self).__len__()
    def __iter__(self):
        for item in self.iter:
            self.append(item)
            yield item
        self.__full=True
    def __fill_list__(self):
        for item in self.iter:
            self.append(item)
        self.__full=True
    def __getitem__(self, i):
        """Support indexing positive/negative elements of the generator,
        but no slices. If you want those, use list(generator)"""
        if not self.__full:
            if i < 0:
                self.__fill_list__()
            elif i >= list.__len__(self):
                diff=i-list.__len__(self)+1
                for j in range(diff):
                    value = next(self.iter)
                    self.append(value)

        return super(_indexable_generator, self).__getitem__(i)

def _generator_from_linked_list(first):
    if first:
        one = first
        while one:
            yield one
            one = one.next

def _list_from_linked_list(first):
    if not first:
        return []

    one = first
    lst = []
    while one:
        lst.append(one)
        one = one.next

# linked lists are stored in reverse order from creation order
    lst.reverse() 
    return lst

# Support using == on bodies, joints, and shapes
def b2ShapeCompare(a, b):
    if not isinstance(a, b2Shape) or not isinstance(b, b2Shape):
        return False
    return __shapeeq(a, b)
def b2BodyCompare(a, b):
    if not isinstance(a, b2Body) or not isinstance(b, b2Body):
        return False
    return __bodyeq(a, b)
def b2JointCompare(a, b):
    if not isinstance(a, b2Joint) or not isinstance(b, b2Joint):
        return False
    return __jointeq(a, b)
def b2FixtureCompare(a, b):
    if not isinstance(a, b2Fixture) or not isinstance(b, b2Fixture):
        return False
    return __fixtureeq(a, b)


_b2Distance = _Box2D._b2Distance

import collections

b2DistanceResult = collections.namedtuple('b2DistanceResult', 
                                          'pointA pointB distance iterations')

def b2Distance(shapeA=None, idxA=0, shapeB=None, idxB=0, transformA=None, transformB=None, useRadii=True):
    """
    Compute the closest points between two shapes.

    Can be called one of two ways:
    + b2Distance(b2DistanceInput)
    This uses the b2DistanceInput structure, where you define your own
    distance proxies

    Or more conveniently using kwargs:
    + b2Distance(shapeA=.., idxA=0, shapeB=.., idxB=0, transformA=..,
                 transformB=.., useRadii=True)

    Returns a namedtuple in the form:
        b2DistanceResult(pointA=(ax, ay), pointB=(bx, by), distance,
                         iterations)
    """
    if isinstance(shapeA, b2DistanceInput):
        out = _b2Distance(shapeA)
    else:
        out = _b2Distance(shapeA, idxA, shapeB, idxB, transformA, transformB, useRadii)

    return b2DistanceResult(pointA=tuple(out.pointA),
                            pointB=tuple(out.pointB),
                            distance=out.distance,
                            iterations=out.iterations)

b2GetPointStates = _Box2D.b2GetPointStates
class b2ContactPoint(object):
    r"""Proxy of C++ b2ContactPoint class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2ContactPoint_swiginit(self,_Box2D.new_b2ContactPoint())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ContactPoint
    fixtureA = property(_Box2D.b2ContactPoint_fixtureA_get, _Box2D.b2ContactPoint_fixtureA_set, doc=r"""fixtureA : p.b2Fixture""")
    fixtureB = property(_Box2D.b2ContactPoint_fixtureB_get, _Box2D.b2ContactPoint_fixtureB_set, doc=r"""fixtureB : p.b2Fixture""")
    normal = property(_Box2D.b2ContactPoint_normal_get, _Box2D.b2ContactPoint_normal_set, doc=r"""normal : b2Vec2""")
    position = property(_Box2D.b2ContactPoint_position_get, _Box2D.b2ContactPoint_position_set, doc=r"""position : b2Vec2""")
    state = property(_Box2D.b2ContactPoint_state_get, _Box2D.b2ContactPoint_state_set, doc=r"""state : b2PointState""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2ContactPoint___hash__)

    def __repr__(self):
        return _format_repr(self) 


# Register b2ContactPoint in _Box2D:
_Box2D.b2ContactPoint_swigregister(b2ContactPoint)
b2Globals = _Box2D.b2Globals

_b2TimeOfImpact = _Box2D._b2TimeOfImpact

def b2TimeOfImpact(shapeA=None, idxA=0, shapeB=None, idxB=0, sweepA=None, sweepB=None, tMax=0.0):
    """
    Compute the upper bound on time before two shapes penetrate. Time is represented as
    a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
    non-tunneling collision. If you change the time interval, you should call this function
    again.
    Note: use b2Distance to compute the contact point and normal at the time of impact.

    Can be called one of several ways:
    + b2TimeOfImpact(b2TOIInput) # utilizes the b2TOIInput structure, where you define your own proxies

    Or utilizing kwargs:
    + b2TimeOfImpact(shapeA=a, shapeB=b, idxA=0, idxB=0, sweepA=sa, sweepB=sb, tMax=t)
    Where idxA and idxB are optional and used only if the shapes are loops (they indicate which section to use.)
    sweep[A,B] are of type b2Sweep.

    Returns a tuple in the form:
    (output state, time of impact)

    Where output state is in b2TOIOutput.[
            e_unknown, 
            e_failed,
            e_overlapped,
            e_touching,
            e_separated ]
    """

    if isinstance(shapeA, b2TOIInput):
        toi_input = shapeA
        out = _b2TimeOfImpact(toi_input)
    else:
        out = _b2TimeOfImpact(shapeA, idxA, shapeB, idxB, sweepA, sweepB, tMax)

    return (out.state, out.t)

class b2AssertException(object):
    r"""Proxy of C++ b2AssertException class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2AssertException___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self):
        r"""__init__(b2AssertException self) -> b2AssertException"""
        _Box2D.b2AssertException_swiginit(self, _Box2D.new_b2AssertException())
    __swig_destroy__ = _Box2D.delete_b2AssertException

# Register b2AssertException in _Box2D:
_Box2D.b2AssertException_swigregister(b2AssertException)

b2_pi = _Box2D.b2_pi

b2_maxManifoldPoints = _Box2D.b2_maxManifoldPoints

b2_maxPolygonVertices = _Box2D.b2_maxPolygonVertices

b2_aabbExtension = _Box2D.b2_aabbExtension

b2_aabbMultiplier = _Box2D.b2_aabbMultiplier

b2_linearSlop = _Box2D.b2_linearSlop

b2_angularSlop = _Box2D.b2_angularSlop

b2_polygonRadius = _Box2D.b2_polygonRadius

b2_maxSubSteps = _Box2D.b2_maxSubSteps

b2_maxTOIContacts = _Box2D.b2_maxTOIContacts

b2_velocityThreshold = _Box2D.b2_velocityThreshold

b2_maxLinearCorrection = _Box2D.b2_maxLinearCorrection

b2_maxAngularCorrection = _Box2D.b2_maxAngularCorrection

b2_maxTranslation = _Box2D.b2_maxTranslation

b2_maxTranslationSquared = _Box2D.b2_maxTranslationSquared

b2_maxRotation = _Box2D.b2_maxRotation

b2_maxRotationSquared = _Box2D.b2_maxRotationSquared

b2_baumgarte = _Box2D.b2_baumgarte

b2_toiBaugarte = _Box2D.b2_toiBaugarte

b2_timeToSleep = _Box2D.b2_timeToSleep

b2_linearSleepTolerance = _Box2D.b2_linearSleepTolerance

b2_angularSleepTolerance = _Box2D.b2_angularSleepTolerance

b2Alloc = _Box2D.b2Alloc
b2Free = _Box2D.b2Free
b2Log = _Box2D.b2Log
class b2Version(object):
    r"""Version numbering scheme. See http://en.wikipedia.org/wiki/Software_versioning"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    major = property(_Box2D.b2Version_major_get, _Box2D.b2Version_major_set, doc=r"""major : int32""")
    minor = property(_Box2D.b2Version_minor_get, _Box2D.b2Version_minor_set, doc=r"""minor : int32""")
    revision = property(_Box2D.b2Version_revision_get, _Box2D.b2Version_revision_set, doc=r"""revision : int32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Version___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __repr__(self):
        return "b2Version(%s.%s.%s)" % (self.major, self.minor, self.revision)


    def __init__(self, **kwargs):
        _Box2D.b2Version_swiginit(self,_Box2D.new_b2Version())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Version

# Register b2Version in _Box2D:
_Box2D.b2Version_swigregister(b2Version)

b2IsValid = _Box2D.b2IsValid
b2InvSqrt = _Box2D.b2InvSqrt
class b2Vec2(object):
    r"""A 2D column vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    SetZero = _swig_new_instance_method(_Box2D.b2Vec2_SetZero)
    Set = _swig_new_instance_method(_Box2D.b2Vec2_Set)
    __neg__ = _swig_new_instance_method(_Box2D.b2Vec2___neg__)
    __call__ = _swig_new_instance_method(_Box2D.b2Vec2___call__)
    __add_vector = _swig_new_instance_method(_Box2D.b2Vec2___add_vector)
    __sub_vector = _swig_new_instance_method(_Box2D.b2Vec2___sub_vector)
    __mul_float = _swig_new_instance_method(_Box2D.b2Vec2___mul_float)
    __Length = _swig_new_instance_method(_Box2D.b2Vec2___Length)
    __LengthSquared = _swig_new_instance_method(_Box2D.b2Vec2___LengthSquared)
    Normalize = _swig_new_instance_method(_Box2D.b2Vec2_Normalize)
    __IsValid = _swig_new_instance_method(_Box2D.b2Vec2___IsValid)
    __Skew = _swig_new_instance_method(_Box2D.b2Vec2___Skew)
    x = property(_Box2D.b2Vec2_x_get, _Box2D.b2Vec2_x_set, doc=r"""x : float32""")
    y = property(_Box2D.b2Vec2_y_get, _Box2D.b2Vec2_y_set, doc=r"""y : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Vec2___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, *args):
        r"""
        __init__(b2Vec2 self, float32 x, float32 y) -> b2Vec2
        __init__(b2Vec2 self) -> b2Vec2
        __init__(b2Vec2 self, b2Vec2 other) -> b2Vec2
        Construct using coordinates.
        """
        _Box2D.b2Vec2_swiginit(self, _Box2D.new_b2Vec2(*args))

    __iter__ = lambda self: iter( (self.x, self.y) )
    __eq__ = lambda self, other: self.__equ(other)
    __ne__ = lambda self,other: not self.__equ(other)
    def __repr__(self):
        return "b2Vec2(%g,%g)" % (self.x, self.y)
    def __len__(self):
        return 2
    def __neg__(self):
        return b2Vec2(-self.x, -self.y)
    def copy(self):
        """
        Return a copy of the vector.
        Remember that the following:
            a = b2Vec2()
            b = a
        Does not copy the vector itself, but b now refers to a.
        """
        return b2Vec2(self.x, self.y)
    __copy__ = copy

    def __iadd__(self, other):
        self.__add_vector(other)
        return self
    def __isub__(self, other):
        self.__sub_vector(other)
        return self
    def __imul__(self, a):
        self.__mul_float(a)
        return self
    def __itruediv__(self, a):
        self.__div_float(a)
        return self
    def __idiv__(self, a):
        self.__div_float(a)
        return self
    def __set(self, x, y):
        self.x = x
        self.y = y
    def __nonzero__(self):
        return self.x!=0.0 or self.y!=0.0

    tuple = property(lambda self: (self.x, self.y), lambda self, value: self.__set(*value))
    length = property(__Length, None)
    lengthSquared = property(__LengthSquared, None)
    valid = property(__IsValid, None)
    skew = property(__Skew, None) 


    cross = _swig_new_instance_method(_Box2D.b2Vec2_cross)
    __getitem__ = _swig_new_instance_method(_Box2D.b2Vec2___getitem__)
    __setitem__ = _swig_new_instance_method(_Box2D.b2Vec2___setitem__)
    __equ = _swig_new_instance_method(_Box2D.b2Vec2___equ)
    dot = _swig_new_instance_method(_Box2D.b2Vec2_dot)
    __truediv__ = _swig_new_instance_method(_Box2D.b2Vec2___truediv__)
    __div__ = _swig_new_instance_method(_Box2D.b2Vec2___div__)
    __mul__ = _swig_new_instance_method(_Box2D.b2Vec2___mul__)
    __add__ = _swig_new_instance_method(_Box2D.b2Vec2___add__)
    __sub__ = _swig_new_instance_method(_Box2D.b2Vec2___sub__)
    __rmul__ = _swig_new_instance_method(_Box2D.b2Vec2___rmul__)
    __rdiv__ = _swig_new_instance_method(_Box2D.b2Vec2___rdiv__)
    __div_float = _swig_new_instance_method(_Box2D.b2Vec2___div_float)
    __swig_destroy__ = _Box2D.delete_b2Vec2

# Register b2Vec2 in _Box2D:
_Box2D.b2Vec2_swigregister(b2Vec2)

class b2Vec3(object):
    r"""A 2D column vector with 3 elements."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    SetZero = _swig_new_instance_method(_Box2D.b2Vec3_SetZero)
    Set = _swig_new_instance_method(_Box2D.b2Vec3_Set)
    __neg__ = _swig_new_instance_method(_Box2D.b2Vec3___neg__)
    __add_vector = _swig_new_instance_method(_Box2D.b2Vec3___add_vector)
    __sub_vector = _swig_new_instance_method(_Box2D.b2Vec3___sub_vector)
    __mul_float = _swig_new_instance_method(_Box2D.b2Vec3___mul_float)
    x = property(_Box2D.b2Vec3_x_get, _Box2D.b2Vec3_x_set, doc=r"""x : float32""")
    y = property(_Box2D.b2Vec3_y_get, _Box2D.b2Vec3_y_set, doc=r"""y : float32""")
    z = property(_Box2D.b2Vec3_z_get, _Box2D.b2Vec3_z_set, doc=r"""z : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Vec3___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, *args):
        r"""
        __init__(b2Vec3 self, float32 x, float32 y, float32 z) -> b2Vec3
        __init__(b2Vec3 self) -> b2Vec3
        __init__(b2Vec3 self, b2Vec3 other) -> b2Vec3
        __init__(b2Vec3 self, b2Vec2 other) -> b2Vec3
        Construct using coordinates.
        """
        _Box2D.b2Vec3_swiginit(self, _Box2D.new_b2Vec3(*args))

    __iter__ = lambda self: iter( (self.x, self.y, self.z) )
    __eq__ = lambda self, other: (self.x == other.x and self.y == other.y and self.z == other.z)
    __ne__ = lambda self, other: (self.x != other.x or self.y != other.y or self.z != other.z)
    def __repr__(self):
        return "b2Vec3(%g,%g,%g)" % (self.x, self.y, self.z)
    def __len__(self):
        return 3
    def __neg__(self):
        return b2Vec3(-self.x, -self.y, -self.z)
    def copy(self):
        """
        Return a copy of the vector.
        Remember that the following:
            a = b2Vec3()
            b = a
        Does not copy the vector itself, but b now refers to a.
        """
        return b2Vec3(self.x, self.y, self.z)
    __copy__ = copy
    def __iadd__(self, other):
        self.__add_vector(other)
        return self
    def __isub__(self, other):
        self.__sub_vector(other)
        return self
    def __imul__(self, a):
        self.__mul_float(a)
        return self
    def __itruediv__(self, a):
        self.__div_float(a)
        return self
    def __idiv__(self, a):
        self.__div_float(a)
        return self
    def dot(self, v):
        """
        Dot product with v (list/tuple or b2Vec3)
        """
        if isinstance(v, (list, tuple)):
            return self.x*v[0] + self.y*v[1] + self.z*v[2]
        else:
            return self.x*v.x + self.y*v.y + self.z*v.z
    def __set(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z
    def __nonzero__(self):
        return self.x!=0.0 or self.y!=0.0 or self.z!=0.0

    tuple = property(lambda self: (self.x, self.y, self.z), lambda self, value: self.__set(*value))
    length = property(_Box2D.b2Vec3___Length, None)
    lengthSquared = property(_Box2D.b2Vec3___LengthSquared, None)
    valid = property(_Box2D.b2Vec3___IsValid, None)


    cross = _swig_new_instance_method(_Box2D.b2Vec3_cross)
    __getitem__ = _swig_new_instance_method(_Box2D.b2Vec3___getitem__)
    __setitem__ = _swig_new_instance_method(_Box2D.b2Vec3___setitem__)
    __IsValid = _swig_new_instance_method(_Box2D.b2Vec3___IsValid)
    __Length = _swig_new_instance_method(_Box2D.b2Vec3___Length)
    __LengthSquared = _swig_new_instance_method(_Box2D.b2Vec3___LengthSquared)
    __truediv__ = _swig_new_instance_method(_Box2D.b2Vec3___truediv__)
    __div__ = _swig_new_instance_method(_Box2D.b2Vec3___div__)
    __mul__ = _swig_new_instance_method(_Box2D.b2Vec3___mul__)
    __add__ = _swig_new_instance_method(_Box2D.b2Vec3___add__)
    __sub__ = _swig_new_instance_method(_Box2D.b2Vec3___sub__)
    __rmul__ = _swig_new_instance_method(_Box2D.b2Vec3___rmul__)
    __rdiv__ = _swig_new_instance_method(_Box2D.b2Vec3___rdiv__)
    __div_float = _swig_new_instance_method(_Box2D.b2Vec3___div_float)
    __swig_destroy__ = _Box2D.delete_b2Vec3

# Register b2Vec3 in _Box2D:
_Box2D.b2Vec3_swigregister(b2Vec3)

class b2Mat22(object):
    r"""A 2-by-2 matrix. Stored in column-major order."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    SetIdentity = _swig_new_instance_method(_Box2D.b2Mat22_SetIdentity)
    SetZero = _swig_new_instance_method(_Box2D.b2Mat22_SetZero)
    __GetInverse = _swig_new_instance_method(_Box2D.b2Mat22___GetInverse)
    Solve = _swig_new_instance_method(_Box2D.b2Mat22_Solve)
    col1 = property(_Box2D.b2Mat22_col1_get, _Box2D.b2Mat22_col1_set, doc=r"""col1 : b2Vec2""")
    col2 = property(_Box2D.b2Mat22_col2_get, _Box2D.b2Mat22_col2_set, doc=r"""col2 : b2Vec2""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Mat22___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, *args):
        r"""
        __init__(b2Mat22 self, b2Vec2 c1, b2Vec2 c2) -> b2Mat22
        __init__(b2Mat22 self, float32 a11, float32 a12, float32 a21, float32 a22) -> b2Mat22
        __init__(b2Mat22 self) -> b2Mat22
        Construct this matrix using an angle. This matrix becomes an orthonormal rotation matrix.
        """
        _Box2D.b2Mat22_swiginit(self, _Box2D.new_b2Mat22(*args))
    __GetAngle = _swig_new_instance_method(_Box2D.b2Mat22___GetAngle)
    __SetAngle = _swig_new_instance_method(_Box2D.b2Mat22___SetAngle)

            # Read-only
    inverse = property(__GetInverse, None)
    angle = property(__GetAngle, __SetAngle)
    ex = property(lambda self: self.col1,
                  lambda self, v: setattr(self, 'col1', v))
    ey = property(lambda self: self.col2,
                  lambda self, v: setattr(self, 'col2', v))
    set = __SetAngle

    __mul__ = _swig_new_instance_method(_Box2D.b2Mat22___mul__)
    __add__ = _swig_new_instance_method(_Box2D.b2Mat22___add__)
    __sub__ = _swig_new_instance_method(_Box2D.b2Mat22___sub__)
    __iadd = _swig_new_instance_method(_Box2D.b2Mat22___iadd)
    __isub = _swig_new_instance_method(_Box2D.b2Mat22___isub)
    __swig_destroy__ = _Box2D.delete_b2Mat22

# Register b2Mat22 in _Box2D:
_Box2D.b2Mat22_swigregister(b2Mat22)

class b2Mat33(object):
    r"""A 3-by-3 matrix. Stored in column-major order."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    SetZero = _swig_new_instance_method(_Box2D.b2Mat33_SetZero)
    Solve33 = _swig_new_instance_method(_Box2D.b2Mat33_Solve33)
    Solve22 = _swig_new_instance_method(_Box2D.b2Mat33_Solve22)
    GetInverse22 = _swig_new_instance_method(_Box2D.b2Mat33_GetInverse22)
    GetSymInverse33 = _swig_new_instance_method(_Box2D.b2Mat33_GetSymInverse33)
    col1 = property(_Box2D.b2Mat33_col1_get, _Box2D.b2Mat33_col1_set, doc=r"""col1 : b2Vec3""")
    col2 = property(_Box2D.b2Mat33_col2_get, _Box2D.b2Mat33_col2_set, doc=r"""col2 : b2Vec3""")
    col3 = property(_Box2D.b2Mat33_col3_get, _Box2D.b2Mat33_col3_set, doc=r"""col3 : b2Vec3""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Mat33___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, *args):
        r"""
        __init__(b2Mat33 self, b2Vec3 c1, b2Vec3 c2, b2Vec3 c3) -> b2Mat33
        __init__(b2Mat33 self) -> b2Mat33
        Construct this matrix using columns.
        """
        _Box2D.b2Mat33_swiginit(self, _Box2D.new_b2Mat33(*args))

    ex = property(lambda self: self.col1, lambda self, v: setattr(self, 'col1', v))
    ey = property(lambda self: self.col2, lambda self, v: setattr(self, 'col2', v))
    ez = property(lambda self: self.col3, lambda self, v: setattr(self, 'col3', v))

    __mul__ = _swig_new_instance_method(_Box2D.b2Mat33___mul__)
    __add__ = _swig_new_instance_method(_Box2D.b2Mat33___add__)
    __sub__ = _swig_new_instance_method(_Box2D.b2Mat33___sub__)
    __iadd = _swig_new_instance_method(_Box2D.b2Mat33___iadd)
    __isub = _swig_new_instance_method(_Box2D.b2Mat33___isub)
    __swig_destroy__ = _Box2D.delete_b2Mat33

# Register b2Mat33 in _Box2D:
_Box2D.b2Mat33_swigregister(b2Mat33)

class b2Rot(object):
    r"""Proxy of C++ b2Rot class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(b2Rot self) -> b2Rot
        __init__(b2Rot self, float32 angle) -> b2Rot
        """
        _Box2D.b2Rot_swiginit(self, _Box2D.new_b2Rot(*args))
    __SetAngle = _swig_new_instance_method(_Box2D.b2Rot___SetAngle)
    SetIdentity = _swig_new_instance_method(_Box2D.b2Rot_SetIdentity)
    __GetAngle = _swig_new_instance_method(_Box2D.b2Rot___GetAngle)
    GetXAxis = _swig_new_instance_method(_Box2D.b2Rot_GetXAxis)
    GetYAxis = _swig_new_instance_method(_Box2D.b2Rot_GetYAxis)
    s = property(_Box2D.b2Rot_s_get, _Box2D.b2Rot_s_set, doc=r"""s : float32""")
    c = property(_Box2D.b2Rot_c_get, _Box2D.b2Rot_c_set, doc=r"""c : float32""")

    angle = property(__GetAngle, __SetAngle) 

    x_axis = property(GetXAxis, None)
    y_axis = property(GetYAxis, None)


    __mul__ = _swig_new_instance_method(_Box2D.b2Rot___mul__)
    __swig_destroy__ = _Box2D.delete_b2Rot

# Register b2Rot in _Box2D:
_Box2D.b2Rot_swigregister(b2Rot)

class b2Transform(object):
    r"""A transform contains translation and rotation. It is used to represent the position and orientation of rigid frames."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(b2Transform self) -> b2Transform
        __init__(b2Transform self, b2Vec2 position, b2Rot rotation) -> b2Transform
        Initialize using a position vector and a rotation matrix.
        """
        _Box2D.b2Transform_swiginit(self, _Box2D.new_b2Transform(*args))
    SetIdentity = _swig_new_instance_method(_Box2D.b2Transform_SetIdentity)
    Set = _swig_new_instance_method(_Box2D.b2Transform_Set)
    position = property(_Box2D.b2Transform_position_get, _Box2D.b2Transform_position_set, doc=r"""position : b2Vec2""")
    q = property(_Box2D.b2Transform_q_get, _Box2D.b2Transform_q_set, doc=r"""q : b2Rot""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Transform___hash__)

    def __repr__(self):
        return _format_repr(self) 

    __get_rotation_matrix = _swig_new_instance_method(_Box2D.b2Transform___get_rotation_matrix)

    def __get_angle(self):
        return self.q.angle
    def __set_angle(self, angle):
        self.q.angle = angle

    def __set_rotation_matrix(self, rot_matrix):
        self.q.angle = rot_matrix.angle

    angle = property(__get_angle, __set_angle) 
    R = property(__get_rotation_matrix, __set_rotation_matrix)

    __mul__ = _swig_new_instance_method(_Box2D.b2Transform___mul__)
    __swig_destroy__ = _Box2D.delete_b2Transform

# Register b2Transform in _Box2D:
_Box2D.b2Transform_swigregister(b2Transform)

class b2Sweep(object):
    r"""This describes the motion of a body/shape for TOI computation. Shapes are defined with respect to the body origin, which may no coincide with the center of mass. However, to support dynamics we must interpolate the center of mass position."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Advance = _swig_new_instance_method(_Box2D.b2Sweep_Advance)
    Normalize = _swig_new_instance_method(_Box2D.b2Sweep_Normalize)
    localCenter = property(_Box2D.b2Sweep_localCenter_get, _Box2D.b2Sweep_localCenter_set, doc=r"""localCenter : b2Vec2""")
    c0 = property(_Box2D.b2Sweep_c0_get, _Box2D.b2Sweep_c0_set, doc=r"""c0 : b2Vec2""")
    c = property(_Box2D.b2Sweep_c_get, _Box2D.b2Sweep_c_set, doc=r"""c : b2Vec2""")
    a0 = property(_Box2D.b2Sweep_a0_get, _Box2D.b2Sweep_a0_set, doc=r"""a0 : float32""")
    a = property(_Box2D.b2Sweep_a_get, _Box2D.b2Sweep_a_set, doc=r"""a : float32""")
    alpha0 = property(_Box2D.b2Sweep_alpha0_get, _Box2D.b2Sweep_alpha0_set, doc=r"""alpha0 : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Sweep___hash__)

    def __repr__(self):
        return _format_repr(self) 

    GetTransform = _swig_new_instance_method(_Box2D.b2Sweep_GetTransform)

    def __init__(self, **kwargs):
        _Box2D.b2Sweep_swiginit(self,_Box2D.new_b2Sweep())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Sweep

# Register b2Sweep in _Box2D:
_Box2D.b2Sweep_swigregister(b2Sweep)

b2DistanceSquared = _Box2D.b2DistanceSquared
b2Dot = _Box2D.b2Dot
b2Cross = _Box2D.b2Cross
b2Mul22 = _Box2D.b2Mul22
b2Mul = _Box2D.b2Mul
b2MulT = _Box2D.b2MulT
b2Abs = _Box2D.b2Abs
b2Min = _Box2D.b2Min
b2Max = _Box2D.b2Max
b2Clamp = _Box2D.b2Clamp
b2NextPowerOfTwo = _Box2D.b2NextPowerOfTwo
b2IsPowerOfTwo = _Box2D.b2IsPowerOfTwo
class b2ContactFeature(object):
    r"""The features that intersect to form the contact point This must be 4 bytes or less."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    e_vertex = _Box2D.b2ContactFeature_e_vertex
    
    e_face = _Box2D.b2ContactFeature_e_face
    
    indexA = property(_Box2D.b2ContactFeature_indexA_get, _Box2D.b2ContactFeature_indexA_set, doc=r"""indexA : uint8""")
    indexB = property(_Box2D.b2ContactFeature_indexB_get, _Box2D.b2ContactFeature_indexB_set, doc=r"""indexB : uint8""")
    typeA = property(_Box2D.b2ContactFeature_typeA_get, _Box2D.b2ContactFeature_typeA_set, doc=r"""typeA : uint8""")
    typeB = property(_Box2D.b2ContactFeature_typeB_get, _Box2D.b2ContactFeature_typeB_set, doc=r"""typeB : uint8""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2ContactFeature___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self):
        r"""
        __init__(b2ContactFeature self) -> b2ContactFeature
        The features that intersect to form the contact point This must be 4 bytes or less.
        """
        _Box2D.b2ContactFeature_swiginit(self, _Box2D.new_b2ContactFeature())
    __swig_destroy__ = _Box2D.delete_b2ContactFeature

# Register b2ContactFeature in _Box2D:
_Box2D.b2ContactFeature_swigregister(b2ContactFeature)
b2Vec2_zero = b2Globals.b2Vec2_zero
b2_nullFeature = b2Globals.b2_nullFeature

class b2ContactID(object):
    r"""Proxy of C++ b2ContactID class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cf = property(_Box2D.b2ContactID_cf_get, _Box2D.b2ContactID_cf_set, doc=r"""cf : b2ContactFeature""")
    key = property(_Box2D.b2ContactID_key_get, _Box2D.b2ContactID_key_set, doc=r"""key : uint32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2ContactID___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2ContactID_swiginit(self,_Box2D.new_b2ContactID())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ContactID

# Register b2ContactID in _Box2D:
_Box2D.b2ContactID_swigregister(b2ContactID)

class b2ManifoldPoint(object):
    r"""A manifold point is a contact point belonging to a contact manifold. It holds details related to the geometry and dynamics of the contact points. The local point usage depends on the manifold type: -e_circles: the local center of circleB -e_faceA: the local center of cirlceB or the clip point of polygonB -e_faceB: the clip point of polygonA This structure is stored across time steps, so we keep it small. Note: the impulses are used for internal caching and may not provide reliable contact forces, especially for high speed collisions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    localPoint = property(_Box2D.b2ManifoldPoint_localPoint_get, _Box2D.b2ManifoldPoint_localPoint_set, doc=r"""localPoint : b2Vec2""")
    normalImpulse = property(_Box2D.b2ManifoldPoint_normalImpulse_get, _Box2D.b2ManifoldPoint_normalImpulse_set, doc=r"""normalImpulse : float32""")
    tangentImpulse = property(_Box2D.b2ManifoldPoint_tangentImpulse_get, _Box2D.b2ManifoldPoint_tangentImpulse_set, doc=r"""tangentImpulse : float32""")
    id = property(_Box2D.b2ManifoldPoint_id_get, _Box2D.b2ManifoldPoint_id_set, doc=r"""id : b2ContactID""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2ManifoldPoint___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2ManifoldPoint_swiginit(self,_Box2D.new_b2ManifoldPoint())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ManifoldPoint

# Register b2ManifoldPoint in _Box2D:
_Box2D.b2ManifoldPoint_swigregister(b2ManifoldPoint)

class b2Manifold(object):
    r"""
    A manifold for two touching convex shapes. Box2D supports multiple types of contact:
    clip point versus plane with radius
    point versus point with radius (circles) The local point usage depends on the manifold type: -e_circles: the local center of circleA -e_faceA: the center of faceA -e_faceB: the center of faceB Similarly the local normal usage: -e_circles: not used -e_faceA: the normal on polygonA -e_faceB: the normal on polygonB We store contacts in this way so that position correction can account for movement, which is critical for continuous physics. All contact scenarios must be expressed in one of these types. This structure is stored across time steps, so we keep it small.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    e_circles = _Box2D.b2Manifold_e_circles
    
    e_faceA = _Box2D.b2Manifold_e_faceA
    
    e_faceB = _Box2D.b2Manifold_e_faceB
    
    localNormal = property(_Box2D.b2Manifold_localNormal_get, _Box2D.b2Manifold_localNormal_set, doc=r"""localNormal : b2Vec2""")
    localPoint = property(_Box2D.b2Manifold_localPoint_get, _Box2D.b2Manifold_localPoint_set, doc=r"""localPoint : b2Vec2""")
    type_ = property(_Box2D.b2Manifold_type__get, _Box2D.b2Manifold_type__set, doc=r"""type_ : b2Manifold::Type""")
    pointCount = property(_Box2D.b2Manifold_pointCount_get, _Box2D.b2Manifold_pointCount_set, doc=r"""pointCount : int32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Manifold___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __GetPoints(self):
        return [self.__GetPoint(i) for i in range(self.pointCount)]
    points = property(__GetPoints, None)

    __GetPoint = _swig_new_instance_method(_Box2D.b2Manifold___GetPoint)

    def __init__(self, **kwargs):
        _Box2D.b2Manifold_swiginit(self,_Box2D.new_b2Manifold())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Manifold

# Register b2Manifold in _Box2D:
_Box2D.b2Manifold_swigregister(b2Manifold)

class b2WorldManifold(object):
    r"""This is used to compute the current state of a contact manifold."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Initialize = _swig_new_instance_method(_Box2D.b2WorldManifold_Initialize)
    normal = property(_Box2D.b2WorldManifold_normal_get, _Box2D.b2WorldManifold_normal_set, doc=r"""normal : b2Vec2""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2WorldManifold___hash__)

    def __repr__(self):
        return _format_repr(self) 



    __get_points = _swig_new_instance_method(_Box2D.b2WorldManifold___get_points)

    points = property(__get_points, None)


    def __init__(self, **kwargs):
        _Box2D.b2WorldManifold_swiginit(self,_Box2D.new_b2WorldManifold())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2WorldManifold

# Register b2WorldManifold in _Box2D:
_Box2D.b2WorldManifold_swigregister(b2WorldManifold)

b2_nullState = _Box2D.b2_nullState

b2_addState = _Box2D.b2_addState

b2_persistState = _Box2D.b2_persistState

b2_removeState = _Box2D.b2_removeState

class b2ClipVertex(object):
    r"""Used for computing contact manifolds."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    v = property(_Box2D.b2ClipVertex_v_get, _Box2D.b2ClipVertex_v_set, doc=r"""v : b2Vec2""")
    id = property(_Box2D.b2ClipVertex_id_get, _Box2D.b2ClipVertex_id_set, doc=r"""id : b2ContactID""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2ClipVertex___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2ClipVertex_swiginit(self,_Box2D.new_b2ClipVertex())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ClipVertex

# Register b2ClipVertex in _Box2D:
_Box2D.b2ClipVertex_swigregister(b2ClipVertex)

class b2RayCastInput(object):
    r"""Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    p1 = property(_Box2D.b2RayCastInput_p1_get, _Box2D.b2RayCastInput_p1_set, doc=r"""p1 : b2Vec2""")
    p2 = property(_Box2D.b2RayCastInput_p2_get, _Box2D.b2RayCastInput_p2_set, doc=r"""p2 : b2Vec2""")
    maxFraction = property(_Box2D.b2RayCastInput_maxFraction_get, _Box2D.b2RayCastInput_maxFraction_set, doc=r"""maxFraction : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2RayCastInput___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2RayCastInput_swiginit(self,_Box2D.new_b2RayCastInput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2RayCastInput

# Register b2RayCastInput in _Box2D:
_Box2D.b2RayCastInput_swigregister(b2RayCastInput)

class b2RayCastOutput(object):
    r"""Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2 come from  b2RayCastInput."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    normal = property(_Box2D.b2RayCastOutput_normal_get, _Box2D.b2RayCastOutput_normal_set, doc=r"""normal : b2Vec2""")
    fraction = property(_Box2D.b2RayCastOutput_fraction_get, _Box2D.b2RayCastOutput_fraction_set, doc=r"""fraction : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2RayCastOutput___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2RayCastOutput_swiginit(self,_Box2D.new_b2RayCastOutput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2RayCastOutput

# Register b2RayCastOutput in _Box2D:
_Box2D.b2RayCastOutput_swigregister(b2RayCastOutput)

class b2AABB(object):
    r"""An axis aligned bounding box."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __IsValid = _swig_new_instance_method(_Box2D.b2AABB___IsValid)
    __GetCenter = _swig_new_instance_method(_Box2D.b2AABB___GetCenter)
    __GetExtents = _swig_new_instance_method(_Box2D.b2AABB___GetExtents)
    __GetPerimeter = _swig_new_instance_method(_Box2D.b2AABB___GetPerimeter)
    Combine = _swig_new_instance_method(_Box2D.b2AABB_Combine)
    RayCast = _swig_new_instance_method(_Box2D.b2AABB_RayCast)
    lowerBound = property(_Box2D.b2AABB_lowerBound_get, _Box2D.b2AABB_lowerBound_set, doc=r"""lowerBound : b2Vec2""")
    upperBound = property(_Box2D.b2AABB_upperBound_get, _Box2D.b2AABB_upperBound_set, doc=r"""upperBound : b2Vec2""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2AABB___hash__)

    def __repr__(self):
        return _format_repr(self) 


            # Read-only
    valid = property(__IsValid, None)
    extents = property(__GetExtents, None)
    center = property(__GetCenter, None)
    perimeter = property(__GetPerimeter, None)


    __contains__ = _swig_new_instance_method(_Box2D.b2AABB___contains__)
    overlaps = _swig_new_instance_method(_Box2D.b2AABB_overlaps)

    def __init__(self, **kwargs):
        _Box2D.b2AABB_swiginit(self,_Box2D.new_b2AABB())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2AABB

# Register b2AABB in _Box2D:
_Box2D.b2AABB_swigregister(b2AABB)

b2CollideCircles = _Box2D.b2CollideCircles
b2CollidePolygonAndCircle = _Box2D.b2CollidePolygonAndCircle
b2CollidePolygons = _Box2D.b2CollidePolygons
b2CollideEdgeAndCircle = _Box2D.b2CollideEdgeAndCircle
b2CollideEdgeAndPolygon = _Box2D.b2CollideEdgeAndPolygon
b2ClipSegmentToLine = _Box2D.b2ClipSegmentToLine
b2TestOverlap = _Box2D.b2TestOverlap
class _b2Vec2Array(object):
    r"""Proxy of C++ _b2Vec2Array class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements):
        r"""__init__(_b2Vec2Array self, size_t nelements) -> _b2Vec2Array"""
        _Box2D._b2Vec2Array_swiginit(self, _Box2D.new__b2Vec2Array(nelements))
    __swig_destroy__ = _Box2D.delete__b2Vec2Array
    __getitem__ = _swig_new_instance_method(_Box2D._b2Vec2Array___getitem__)
    __setitem__ = _swig_new_instance_method(_Box2D._b2Vec2Array___setitem__)
    cast = _swig_new_instance_method(_Box2D._b2Vec2Array_cast)
    frompointer = _swig_new_static_method(_Box2D._b2Vec2Array_frompointer)

# Register _b2Vec2Array in _Box2D:
_Box2D._b2Vec2Array_swigregister(_b2Vec2Array)
_b2Vec2Array_frompointer = _Box2D._b2Vec2Array_frompointer

e_convertVertices = _Box2D.e_convertVertices

class b2Color(object):
    r"""Color for debug drawing. Each value has the range [0,1]."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Set = _swig_new_instance_method(_Box2D.b2Color_Set)
    r = property(_Box2D.b2Color_r_get, _Box2D.b2Color_r_set, doc=r"""r : float32""")
    g = property(_Box2D.b2Color_g_get, _Box2D.b2Color_g_set, doc=r"""g : float32""")
    b = property(_Box2D.b2Color_b_get, _Box2D.b2Color_b_set, doc=r"""b : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Color___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, *args):
        r"""
        __init__(b2Color self) -> b2Color
        __init__(b2Color self, float32 r, float32 g, float32 b) -> b2Color
        __init__(b2Color self, b2Color other) -> b2Color
        Color for debug drawing. Each value has the range [0,1].
        """
        _Box2D.b2Color_swiginit(self, _Box2D.new_b2Color(*args))
    __get_bytes = _swig_new_instance_method(_Box2D.b2Color___get_bytes)

    __iter__ = lambda self: iter((self.r, self.g, self.b)) 
    __eq__ = lambda self, other: self.__equ(other)
    __ne__ = lambda self,other: not self.__equ(other)
    def __repr__(self):
        return "b2Color(%g,%g,%g)" % (self.r, self.g, self.b)
    def __len__(self):
        return 3
    def __copy__(self):
        return b2Color(self.r, self.g, self.b)
    def copy(self):
        return b2Color(self.r, self.g, self.b)
    def __set_bytes(self, value):
        if len(value) != 3:
            raise ValueError('Expected length 3 list')
        self.r, self.g, self.b = value[0]/255, value[1]/255, value[2]/255
    def __set_tuple(self, value):
        if len(value) != 3:
            raise ValueError('Expected length 3 list')
        self.r, self.g, self.b = value[0], value[1], value[2]
    def __nonzero__(self):
        return self.r!=0.0 or self.g!=0.0 or self.b!=0.0

    list  = property(lambda self: list(self), __set_tuple)
    bytes = property(__get_bytes, __set_bytes)

    __getitem__ = _swig_new_instance_method(_Box2D.b2Color___getitem__)
    __setitem__ = _swig_new_instance_method(_Box2D.b2Color___setitem__)
    __truediv__ = _swig_new_instance_method(_Box2D.b2Color___truediv__)
    __add__ = _swig_new_instance_method(_Box2D.b2Color___add__)
    __sub__ = _swig_new_instance_method(_Box2D.b2Color___sub__)
    __div__ = _swig_new_instance_method(_Box2D.b2Color___div__)
    __rmul__ = _swig_new_instance_method(_Box2D.b2Color___rmul__)
    __mul__ = _swig_new_instance_method(_Box2D.b2Color___mul__)
    __isub = _swig_new_instance_method(_Box2D.b2Color___isub)
    __itruediv = _swig_new_instance_method(_Box2D.b2Color___itruediv)
    __idiv = _swig_new_instance_method(_Box2D.b2Color___idiv)
    __imul = _swig_new_instance_method(_Box2D.b2Color___imul)
    __iadd = _swig_new_instance_method(_Box2D.b2Color___iadd)
    __equ = _swig_new_instance_method(_Box2D.b2Color___equ)
    __swig_destroy__ = _Box2D.delete_b2Color

# Register b2Color in _Box2D:
_Box2D.b2Color_swigregister(b2Color)

class b2Draw(object):
    r"""Implement and register this class with a  b2Worldto provide debug drawing of physics entities in your game."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        if self.__class__ == b2Draw:
            _self = None
        else:
            _self = self
        _Box2D.b2Draw_swiginit(self,_Box2D.new_b2Draw(_self, ))
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Draw
    e_shapeBit = _Box2D.b2Draw_e_shapeBit
    
    e_jointBit = _Box2D.b2Draw_e_jointBit
    
    e_aabbBit = _Box2D.b2Draw_e_aabbBit
    
    e_pairBit = _Box2D.b2Draw_e_pairBit
    
    e_centerOfMassBit = _Box2D.b2Draw_e_centerOfMassBit
    
    __SetFlags = _swig_new_instance_method(_Box2D.b2Draw___SetFlags)
    __GetFlags = _swig_new_instance_method(_Box2D.b2Draw___GetFlags)
    AppendFlags = _swig_new_instance_method(_Box2D.b2Draw_AppendFlags)
    ClearFlags = _swig_new_instance_method(_Box2D.b2Draw_ClearFlags)
    DrawPolygon = _swig_new_instance_method(_Box2D.b2Draw_DrawPolygon)
    DrawSolidPolygon = _swig_new_instance_method(_Box2D.b2Draw_DrawSolidPolygon)
    DrawCircle = _swig_new_instance_method(_Box2D.b2Draw_DrawCircle)
    DrawSolidCircle = _swig_new_instance_method(_Box2D.b2Draw_DrawSolidCircle)
    DrawSegment = _swig_new_instance_method(_Box2D.b2Draw_DrawSegment)
    DrawTransform = _swig_new_instance_method(_Box2D.b2Draw_DrawTransform)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Draw___hash__)

    def __repr__(self):
        return _format_repr(self) 


    _flag_entries = [
        ['drawShapes', e_shapeBit],
        ['drawJoints', e_jointBit ],
        ['drawAABBs', e_aabbBit ],
        ['drawPairs', e_pairBit ],
        ['drawCOMs', e_centerOfMassBit ],
        ['convertVertices', e_convertVertices ],
    ]
    def _SetFlags(self, value):
        flags = 0
        for name_, mask in self._flag_entries:
            if name_ in value and value[name_]:
                flags |= mask
        self.__SetFlags(flags)
    def _GetFlags(self):
        flags = self.__GetFlags()
        ret={}
        for name_, mask in self._flag_entries:
            ret[name_]=((flags & mask)==mask)
        return ret

    flags=property(_GetFlags, _SetFlags, doc='Sets whether or not shapes, joints, etc. will be drawn.')

    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2Draw(self)
        return weakref.proxy(self)

# Register b2Draw in _Box2D:
_Box2D.b2Draw_swigregister(b2Draw)

class b2DrawExtended(b2Draw):
    r"""Proxy of C++ b2DrawExtended class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    convertVertices = property(_Box2D.b2DrawExtended_convertVertices_get, _Box2D.b2DrawExtended_convertVertices_set, doc=r"""convertVertices : bool""")
    center = property(_Box2D.b2DrawExtended_center_get, _Box2D.b2DrawExtended_center_set, doc=r"""center : b2Vec2""")
    offset = property(_Box2D.b2DrawExtended_offset_get, _Box2D.b2DrawExtended_offset_set, doc=r"""offset : b2Vec2""")
    zoom = property(_Box2D.b2DrawExtended_zoom_get, _Box2D.b2DrawExtended_zoom_set, doc=r"""zoom : float32""")
    screenSize = property(_Box2D.b2DrawExtended_screenSize_get, _Box2D.b2DrawExtended_screenSize_set, doc=r"""screenSize : b2Vec2""")
    flipY = property(_Box2D.b2DrawExtended_flipY_get, _Box2D.b2DrawExtended_flipY_set, doc=r"""flipY : bool""")
    flipX = property(_Box2D.b2DrawExtended_flipX_get, _Box2D.b2DrawExtended_flipX_set, doc=r"""flipX : bool""")
    __Convert = _swig_new_instance_method(_Box2D.b2DrawExtended___Convert)
    to_screen = _swig_new_instance_method(_Box2D.b2DrawExtended_to_screen)
    DrawPolygon = _swig_new_instance_method(_Box2D.b2DrawExtended_DrawPolygon)
    DrawSolidPolygon = _swig_new_instance_method(_Box2D.b2DrawExtended_DrawSolidPolygon)
    DrawCircle = _swig_new_instance_method(_Box2D.b2DrawExtended_DrawCircle)
    DrawSolidCircle = _swig_new_instance_method(_Box2D.b2DrawExtended_DrawSolidCircle)
    DrawSegment = _swig_new_instance_method(_Box2D.b2DrawExtended_DrawSegment)
    DrawTransform = _swig_new_instance_method(_Box2D.b2DrawExtended_DrawTransform)
    __SetFlags = _swig_new_instance_method(_Box2D.b2DrawExtended___SetFlags)
    __swig_destroy__ = _Box2D.delete_b2DrawExtended

    def __init__(self, **kwargs):
        if self.__class__ == b2DrawExtended:
            _self = None
        else:
            _self = self
        _Box2D.b2DrawExtended_swiginit(self,_Box2D.new_b2DrawExtended(_self, ))
        _init_kwargs(self, **kwargs)



    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2DrawExtended___hash__)

    def __repr__(self):
        return _format_repr(self) 

    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2DrawExtended(self)
        return weakref.proxy(self)

# Register b2DrawExtended in _Box2D:
_Box2D.b2DrawExtended_swigregister(b2DrawExtended)

class b2MassData(object):
    r"""This holds the mass data computed for a shape."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    mass = property(_Box2D.b2MassData_mass_get, _Box2D.b2MassData_mass_set, doc=r"""mass : float32""")
    center = property(_Box2D.b2MassData_center_get, _Box2D.b2MassData_center_set, doc=r"""center : b2Vec2""")
    I = property(_Box2D.b2MassData_I_get, _Box2D.b2MassData_I_set, doc=r"""I : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2MassData___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2MassData_swiginit(self,_Box2D.new_b2MassData())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2MassData

# Register b2MassData in _Box2D:
_Box2D.b2MassData_swigregister(b2MassData)
b2_chunkSize = b2Globals.b2_chunkSize
b2_maxBlockSize = b2Globals.b2_maxBlockSize
b2_blockSizes = b2Globals.b2_blockSizes
b2_chunkArrayIncrement = b2Globals.b2_chunkArrayIncrement

class b2Shape(object):
    r"""A shape is used for collision detection. You can create a shape however you like. Shapes used for simulation in  b2Worldare created automatically when a  b2Fixtureis created. Shapes may encapsulate a one or more child shapes."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    e_circle = _Box2D.b2Shape_e_circle
    
    e_edge = _Box2D.b2Shape_e_edge
    
    e_polygon = _Box2D.b2Shape_e_polygon
    
    e_chain = _Box2D.b2Shape_e_chain
    
    e_typeCount = _Box2D.b2Shape_e_typeCount
    
    __swig_destroy__ = _Box2D.delete_b2Shape
    __GetType = _swig_new_instance_method(_Box2D.b2Shape___GetType)
    __GetChildCount = _swig_new_instance_method(_Box2D.b2Shape___GetChildCount)
    TestPoint = _swig_new_instance_method(_Box2D.b2Shape_TestPoint)
    RayCast = _swig_new_instance_method(_Box2D.b2Shape_RayCast)
    __ComputeAABB = _swig_new_instance_method(_Box2D.b2Shape___ComputeAABB)
    __ComputeMass = _swig_new_instance_method(_Box2D.b2Shape___ComputeMass)
    radius = property(_Box2D.b2Shape_radius_get, _Box2D.b2Shape_radius_set, doc=r"""radius : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Shape___hash__)

    def __repr__(self):
        return _format_repr(self) 


    __eq__ = b2ShapeCompare
    __ne__ = lambda self,other: not b2ShapeCompare(self,other)
    # Read-only
    type = property(__GetType, None)

    def getAsType(self):
        return self

    @property
    def childCount(self):
        """
        Get the number of child primitives.
        """
        return self.__GetChildCount()

    def getAABB(self, transform, childIndex):
        """
        Given a transform, compute the associated axis aligned bounding box for a child shape.
        """
        if childIndex >= self.childCount:
            raise ValueError('Child index should be at most childCount=%d' % self.childCount)
        aabb=b2AABB()
        self.__ComputeAABB(aabb, transform, childIndex)
        return aabb

    def getMass(self, density):
        """
        Compute the mass properties of this shape using its dimensions and density.
        The inertia tensor is computed about the local origin.
        """
        m=b2MassData()
        self.__ComputeMass(m, density)
        return m



# Register b2Shape in _Box2D:
_Box2D.b2Shape_swigregister(b2Shape)

class b2CircleShape(b2Shape):
    r"""A circle shape."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2CircleShape_swiginit(self,_Box2D.new_b2CircleShape())
        _init_kwargs(self, **kwargs)


    pos = property(_Box2D.b2CircleShape_pos_get, _Box2D.b2CircleShape_pos_set, doc=r"""pos : b2Vec2""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2CircleShape___hash__)

    def __repr__(self):
        return _format_repr(self) 



    __swig_destroy__ = _Box2D.delete_b2CircleShape

# Register b2CircleShape in _Box2D:
_Box2D.b2CircleShape_swigregister(b2CircleShape)

class b2EdgeShape(b2Shape):
    r"""A line segment (edge) shape. These can be connected in chains or loops to other edge shapes. The connectivity information is used to ensure correct contact normals."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2EdgeShape_swiginit(self,_Box2D.new_b2EdgeShape())
        _init_kwargs(self, **kwargs)


    __Set = _swig_new_instance_method(_Box2D.b2EdgeShape___Set)
    vertex1 = property(_Box2D.b2EdgeShape_vertex1_get, _Box2D.b2EdgeShape_vertex1_set, doc=r"""vertex1 : b2Vec2""")
    vertex2 = property(_Box2D.b2EdgeShape_vertex2_get, _Box2D.b2EdgeShape_vertex2_set, doc=r"""vertex2 : b2Vec2""")
    vertex0 = property(_Box2D.b2EdgeShape_vertex0_get, _Box2D.b2EdgeShape_vertex0_set, doc=r"""vertex0 : b2Vec2""")
    vertex3 = property(_Box2D.b2EdgeShape_vertex3_get, _Box2D.b2EdgeShape_vertex3_set, doc=r"""vertex3 : b2Vec2""")
    hasVertex0 = property(_Box2D.b2EdgeShape_hasVertex0_get, _Box2D.b2EdgeShape_hasVertex0_set, doc=r"""hasVertex0 : bool""")
    hasVertex3 = property(_Box2D.b2EdgeShape_hasVertex3_get, _Box2D.b2EdgeShape_hasVertex3_set, doc=r"""hasVertex3 : bool""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2EdgeShape___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __repr__(self):
        return "b2EdgeShape(vertices: %s)" % (self.vertices)

    @property
    def all_vertices(self):
        """Returns all of the vertices as a list of tuples [ (x0,y0), (x1,y1), (x2,y2) (x3,y3) ]
        Note that the validity of vertices 0 and 4 depend on whether or not
        hasVertex0 and hasVertex3 are set.
        """
        return [tuple(self.vertex0), tuple(self.vertex1), tuple(self.vertex2), tuple(self.vertex3)]

    def __get_vertices(self):
        """Returns the basic vertices as a list of tuples [ (x1,y1), (x2,y2) ]
        To include the supporting vertices, see 'all_vertices'

        If you want to set vertex3 but not vertex0, pass in None for vertex0.
        """
        return [tuple(self.vertex1), tuple(self.vertex2)]

    def __set_vertices(self, vertices):
        if len(vertices)==2:
            self.vertex1, self.vertex2=vertices
            self.hasVertex0=False
            self.hasVertex3=False
        elif len(vertices)==3:
            self.vertex0, self.vertex1, self.vertex2=vertices
            self.hasVertex0=(vertices[0] != None)
            self.hasVertex3=False
        elif len(vertices)==4:
            self.vertex0, self.vertex1, self.vertex2, self.vertex3=vertices
            self.hasVertex0=(vertices[0] != None)
            self.hasVertex3=True
        else:
            raise ValueError('Expected from 2 to 4 vertices.')

    @property
    def vertexCount(self):
        """
        Returns the number of valid vertices (as in, it counts whether or not 
        hasVertex0 or hasVertex3 are set)
        """
        if self.hasVertex0 and self.hasVertex3:
            return 4
        elif self.hasVertex0 or self.hasVertex3:
            return 3
        else:
            return 2

    def __iter__(self):
        """
        Iterates over the vertices in the Edge
        """
        for v in self.vertices:
            yield v

    vertices=property(__get_vertices, __set_vertices)

    __swig_destroy__ = _Box2D.delete_b2EdgeShape

# Register b2EdgeShape in _Box2D:
_Box2D.b2EdgeShape_swigregister(b2EdgeShape)

class b2ChainShape(b2Shape):
    r"""A loop shape is a free form sequence of line segments that form a circular list. The loop may cross upon itself, but this is not recommended for smooth collision. The loop has double sided collision, so you can use inside and outside collision. Therefore, you may use any winding order. Since there may be many vertices, they are allocated using b2Alloc."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2ChainShape_swiginit(self,_Box2D.new_b2ChainShape())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ChainShape
    CreateLoop = _swig_new_instance_method(_Box2D.b2ChainShape_CreateLoop)
    CreateChain = _swig_new_instance_method(_Box2D.b2ChainShape_CreateChain)
    SetPrevVertex = _swig_new_instance_method(_Box2D.b2ChainShape_SetPrevVertex)
    SetNextVertex = _swig_new_instance_method(_Box2D.b2ChainShape_SetNextVertex)
    __GetChildEdge = _swig_new_instance_method(_Box2D.b2ChainShape___GetChildEdge)
    m_prevVertex = property(_Box2D.b2ChainShape_m_prevVertex_get, _Box2D.b2ChainShape_m_prevVertex_set, doc=r"""m_prevVertex : b2Vec2""")
    m_nextVertex = property(_Box2D.b2ChainShape_m_nextVertex_get, _Box2D.b2ChainShape_m_nextVertex_set, doc=r"""m_nextVertex : b2Vec2""")
    m_hasPrevVertex = property(_Box2D.b2ChainShape_m_hasPrevVertex_get, _Box2D.b2ChainShape_m_hasPrevVertex_set, doc=r"""m_hasPrevVertex : bool""")
    m_hasNextVertex = property(_Box2D.b2ChainShape_m_hasNextVertex_get, _Box2D.b2ChainShape_m_hasNextVertex_set, doc=r"""m_hasNextVertex : bool""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2ChainShape___hash__)

    def __repr__(self):
        return _format_repr(self) 

    __get_vertices = _swig_new_instance_method(_Box2D.b2ChainShape___get_vertices)

    def __repr__(self):
        return "b2ChainShape(vertices: %s)" % (self.vertices)

    def getChildEdge(self, index):
        if childIndex >= self.childCount:
            raise ValueError('Child index should be at most childCount=%d' % self.childCount)

        edge=b2EdgeShape()
        self.__GetChildEdge(edge, index)
        return edge

    @property
    def edges(self):
        return [self.getChildEdge(i) for i in range(self.childCount)]

    @property
    def vertexCount(self):
        return self.__get_count()

    def __get_vertices(self):
        """Returns all of the vertices as a list of tuples [ (x1,y1), (x2,y2) ... (xN,yN) ]"""
        return [ (self.__get_vertex(i).x, self.__get_vertex(i).y )
                         for i in range(0, self.vertexCount)]

    def __iter__(self):
        """
        Iterates over the vertices in the Chain
        """
        for v in self.vertices:
            yield v

    def __set_vertices(self, values, loop=True):
        if not values or not isinstance(values, (list, tuple)) or (len(values) < 2):
            raise ValueError('Expected tuple or list of length >= 2.')

        for i,value in enumerate(values):
            if isinstance(value, (tuple, list)):
                if len(value) != 2:
                    raise ValueError('Expected tuple or list of length 2, got length %d' % len(value))
                for j in value:
                     if not isinstance(j, (int, float)):
                        raise ValueError('Expected int or float values, got %s' % (type(j)))
            elif isinstance(value, b2Vec2):
                pass
            else:
                raise ValueError('Expected tuple, list, or b2Vec2, got %s' % type(value))

        vecs=_b2Vec2Array(len(values))
        for i, value in enumerate(values):
            if isinstance(value, b2Vec2):
                vecs[i]=value
            else:
                vecs[i]=b2Vec2(value)

        self.__create(vecs, len(values), loop)

    vertices = property(__get_vertices, __set_vertices)
    vertices_chain = property(__get_vertices, lambda self, v : self.__set_vertices(v, loop=False))
    vertices_loop = vertices

    __create = _swig_new_instance_method(_Box2D.b2ChainShape___create)
    __get_vertex = _swig_new_instance_method(_Box2D.b2ChainShape___get_vertex)
    __get_count = _swig_new_instance_method(_Box2D.b2ChainShape___get_count)

# Register b2ChainShape in _Box2D:
_Box2D.b2ChainShape_swigregister(b2ChainShape)

class b2PolygonShape(b2Shape):
    r"""A convex polygon. It is assumed that the interior of the polygon is to the left of each edge. Polygons have a maximum number of vertices equal to b2_maxPolygonVertices. In most cases you should not need many vertices for a convex polygon."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2PolygonShape_swiginit(self,_Box2D.new_b2PolygonShape())
        _init_kwargs(self, **kwargs)


    SetAsBox = _swig_new_instance_method(_Box2D.b2PolygonShape_SetAsBox)
    Validate = _swig_new_instance_method(_Box2D.b2PolygonShape_Validate)
    centroid = property(_Box2D.b2PolygonShape_centroid_get, _Box2D.b2PolygonShape_centroid_set, doc=r"""centroid : b2Vec2""")
    vertexCount = property(_Box2D.b2PolygonShape_vertexCount_get, _Box2D.b2PolygonShape_vertexCount_set, doc=r"""vertexCount : int32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2PolygonShape___hash__)

    def __repr__(self):
        return _format_repr(self) 

    __get_vertices = _swig_new_instance_method(_Box2D.b2PolygonShape___get_vertices)
    __get_normals = _swig_new_instance_method(_Box2D.b2PolygonShape___get_normals)

    def __repr__(self):
        return "b2PolygonShape(vertices: %s)" % (self.vertices)
    def __clear_vertices(self):
        self.vertexCount=0
        for i in range(0, b2_maxPolygonVertices):
            self.set_vertex(i, 0, 0)
    def __set_vertices(self, values):
        if not values:
            self.__clear_vertices()
        else:
            if len(values) < 2 or len(values) > b2_maxPolygonVertices:
                raise ValueError('Expected tuple or list of length >= 2 and less than b2_maxPolygonVertices=%d, got length %d.' %
                                     (b2_maxPolygonVertices, len(values)))
            for i,value in enumerate(values):
                if isinstance(value, (tuple, list, b2Vec2)):
                    if len(value) != 2:
                        raise ValueError('Expected tuple or list of length 2, got length %d' % len(value))
                    self.set_vertex(i, *value)
                else:
                    raise ValueError('Expected tuple, list, or b2Vec2, got %s' % type(value))
                self.vertexCount=i+1 # follow along in case of an exception to indicate valid number set

            self.__set_vertices_internal() # calculates normals, centroid, etc.

    def __iter__(self):
        """
        Iterates over the vertices in the polygon
        """
        for v in self.vertices:
            yield v

    def __IsValid(self):
        return b2CheckPolygon(self)

    valid = property(__IsValid, None, doc="Checks the polygon to see if it can be properly created. Raises ValueError for invalid shapes.")
    vertices = property(__get_vertices, __set_vertices, doc="All of the vertices as a list of tuples [ (x1,y1), (x2,y2) ... (xN,yN) ]")
    normals = property(__get_normals, None, doc="All of the normals as a list of tuples [ (x1,y1), (x2,y2) ... (xN,yN) ]")
    box = property(None, lambda self, value: self.SetAsBox(*value), doc="Property replacement for running SetAsBox (Write-only)")

    __get_vertex = _swig_new_instance_method(_Box2D.b2PolygonShape___get_vertex)
    __get_normal = _swig_new_instance_method(_Box2D.b2PolygonShape___get_normal)
    set_vertex = _swig_new_instance_method(_Box2D.b2PolygonShape_set_vertex)
    __set_vertices_internal = _swig_new_instance_method(_Box2D.b2PolygonShape___set_vertices_internal)
    __swig_destroy__ = _Box2D.delete_b2PolygonShape

# Register b2PolygonShape in _Box2D:
_Box2D.b2PolygonShape_swigregister(b2PolygonShape)

b2_nullNode = _Box2D.b2_nullNode

class b2TreeNode(object):
    r"""Proxy of C++ b2TreeNode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    IsLeaf = _swig_new_instance_method(_Box2D.b2TreeNode_IsLeaf)
    aabb = property(_Box2D.b2TreeNode_aabb_get, _Box2D.b2TreeNode_aabb_set, doc=r"""aabb : b2AABB""")
    child1 = property(_Box2D.b2TreeNode_child1_get, _Box2D.b2TreeNode_child1_set, doc=r"""child1 : int32""")
    child2 = property(_Box2D.b2TreeNode_child2_get, _Box2D.b2TreeNode_child2_set, doc=r"""child2 : int32""")
    height = property(_Box2D.b2TreeNode_height_get, _Box2D.b2TreeNode_height_set, doc=r"""height : int32""")

    def __init__(self):
        r"""__init__(b2TreeNode self) -> b2TreeNode"""
        _Box2D.b2TreeNode_swiginit(self, _Box2D.new_b2TreeNode())
    __swig_destroy__ = _Box2D.delete_b2TreeNode

# Register b2TreeNode in _Box2D:
_Box2D.b2TreeNode_swigregister(b2TreeNode)

class b2Pair(object):
    r"""Proxy of C++ b2Pair class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    proxyIdA = property(_Box2D.b2Pair_proxyIdA_get, _Box2D.b2Pair_proxyIdA_set, doc=r"""proxyIdA : int32""")
    proxyIdB = property(_Box2D.b2Pair_proxyIdB_get, _Box2D.b2Pair_proxyIdB_set, doc=r"""proxyIdB : int32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Pair___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2Pair_swiginit(self,_Box2D.new_b2Pair())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Pair

# Register b2Pair in _Box2D:
_Box2D.b2Pair_swigregister(b2Pair)

class b2BroadPhase(object):
    r"""The broad-phase is used for computing pairs and performing volume queries and ray casts. This broad-phase does not persist pairs. Instead, this reports potentially new pairs. It is up to the client to consume the new pairs and to track subsequent overlap."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    e_nullProxy = _Box2D.b2BroadPhase_e_nullProxy
    

    def __init__(self):
        r"""
        __init__(b2BroadPhase self) -> b2BroadPhase
        The broad-phase is used for computing pairs and performing volume queries and ray casts. This broad-phase does not persist pairs. Instead, this reports potentially new pairs. It is up to the client to consume the new pairs and to track subsequent overlap.
        """
        _Box2D.b2BroadPhase_swiginit(self, _Box2D.new_b2BroadPhase())
    __swig_destroy__ = _Box2D.delete_b2BroadPhase
    MoveProxy = _swig_new_instance_method(_Box2D.b2BroadPhase_MoveProxy)
    TouchProxy = _swig_new_instance_method(_Box2D.b2BroadPhase_TouchProxy)
    GetFatAABB = _swig_new_instance_method(_Box2D.b2BroadPhase_GetFatAABB)
    TestOverlap = _swig_new_instance_method(_Box2D.b2BroadPhase_TestOverlap)
    __GetProxyCount = _swig_new_instance_method(_Box2D.b2BroadPhase___GetProxyCount)
    __GetTreeHeight = _swig_new_instance_method(_Box2D.b2BroadPhase___GetTreeHeight)
    __GetTreeBalance = _swig_new_instance_method(_Box2D.b2BroadPhase___GetTreeBalance)
    __GetTreeQuality = _swig_new_instance_method(_Box2D.b2BroadPhase___GetTreeQuality)
    ShiftOrigin = _swig_new_instance_method(_Box2D.b2BroadPhase_ShiftOrigin)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2BroadPhase___hash__)

    def __repr__(self):
        return _format_repr(self) 


    proxyCount=property(__GetProxyCount, None)
    treeHeight=property(__GetTreeHeight, None)
    treeBalance=property(__GetTreeBalance, None)
    treeQuality=property(__GetTreeQuality, None)


# Register b2BroadPhase in _Box2D:
_Box2D.b2BroadPhase_swigregister(b2BroadPhase)

b2PairLessThan = _Box2D.b2PairLessThan
class b2DistanceProxy(object):
    r"""A distance proxy is used by the GJK algorithm. It encapsulates any shape."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, shape, index=0):
        _Box2D.b2DistanceProxy_swiginit(self,_Box2D.new_b2DistanceProxy())
        self.Set(shape, index)


    Set = _swig_new_instance_method(_Box2D.b2DistanceProxy_Set)
    GetSupport = _swig_new_instance_method(_Box2D.b2DistanceProxy_GetSupport)
    GetSupportVertex = _swig_new_instance_method(_Box2D.b2DistanceProxy_GetSupportVertex)
    __get_vertex_count = _swig_new_instance_method(_Box2D.b2DistanceProxy___get_vertex_count)
    __get_vertex = _swig_new_instance_method(_Box2D.b2DistanceProxy___get_vertex)
    m_buffer = property(_Box2D.b2DistanceProxy_m_buffer_get, _Box2D.b2DistanceProxy_m_buffer_set, doc=r"""m_buffer : a(2).b2Vec2""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2DistanceProxy___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __get_vertices(self):
        """Returns all of the vertices as a list of tuples [ (x1,y1), (x2,y2) ... (xN,yN) ]"""
        return [ (self.__get_vertex(i).x, self.__get_vertex(i).y )
                         for i in range(0, self.__get_vertex_count())]
    vertices = property(__get_vertices, None)

    __swig_destroy__ = _Box2D.delete_b2DistanceProxy

# Register b2DistanceProxy in _Box2D:
_Box2D.b2DistanceProxy_swigregister(b2DistanceProxy)

class b2DistanceInput(object):
    r"""Input for b2Distance. You have to option to use the shape radii in the computation. Even"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    proxyA = property(_Box2D.b2DistanceInput_proxyA_get, _Box2D.b2DistanceInput_proxyA_set, doc=r"""proxyA : b2DistanceProxy""")
    proxyB = property(_Box2D.b2DistanceInput_proxyB_get, _Box2D.b2DistanceInput_proxyB_set, doc=r"""proxyB : b2DistanceProxy""")
    transformA = property(_Box2D.b2DistanceInput_transformA_get, _Box2D.b2DistanceInput_transformA_set, doc=r"""transformA : b2Transform""")
    transformB = property(_Box2D.b2DistanceInput_transformB_get, _Box2D.b2DistanceInput_transformB_set, doc=r"""transformB : b2Transform""")
    useRadii = property(_Box2D.b2DistanceInput_useRadii_get, _Box2D.b2DistanceInput_useRadii_set, doc=r"""useRadii : bool""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2DistanceInput___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2DistanceInput_swiginit(self,_Box2D.new_b2DistanceInput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2DistanceInput

# Register b2DistanceInput in _Box2D:
_Box2D.b2DistanceInput_swigregister(b2DistanceInput)

class b2DistanceOutput(object):
    r"""Output for b2Distance."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pointA = property(_Box2D.b2DistanceOutput_pointA_get, _Box2D.b2DistanceOutput_pointA_set, doc=r"""pointA : b2Vec2""")
    pointB = property(_Box2D.b2DistanceOutput_pointB_get, _Box2D.b2DistanceOutput_pointB_set, doc=r"""pointB : b2Vec2""")
    distance = property(_Box2D.b2DistanceOutput_distance_get, _Box2D.b2DistanceOutput_distance_set, doc=r"""distance : float32""")
    iterations = property(_Box2D.b2DistanceOutput_iterations_get, _Box2D.b2DistanceOutput_iterations_set, doc=r"""iterations : int32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2DistanceOutput___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2DistanceOutput_swiginit(self,_Box2D.new_b2DistanceOutput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2DistanceOutput

# Register b2DistanceOutput in _Box2D:
_Box2D.b2DistanceOutput_swigregister(b2DistanceOutput)

class b2TOIInput(object):
    r"""Input parameters for b2TimeOfImpact."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    proxyA = property(_Box2D.b2TOIInput_proxyA_get, _Box2D.b2TOIInput_proxyA_set, doc=r"""proxyA : b2DistanceProxy""")
    proxyB = property(_Box2D.b2TOIInput_proxyB_get, _Box2D.b2TOIInput_proxyB_set, doc=r"""proxyB : b2DistanceProxy""")
    sweepA = property(_Box2D.b2TOIInput_sweepA_get, _Box2D.b2TOIInput_sweepA_set, doc=r"""sweepA : b2Sweep""")
    sweepB = property(_Box2D.b2TOIInput_sweepB_get, _Box2D.b2TOIInput_sweepB_set, doc=r"""sweepB : b2Sweep""")
    tMax = property(_Box2D.b2TOIInput_tMax_get, _Box2D.b2TOIInput_tMax_set, doc=r"""tMax : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2TOIInput___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2TOIInput_swiginit(self,_Box2D.new_b2TOIInput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2TOIInput

# Register b2TOIInput in _Box2D:
_Box2D.b2TOIInput_swigregister(b2TOIInput)

class b2TOIOutput(object):
    r"""Proxy of C++ b2TOIOutput class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    e_unknown = _Box2D.b2TOIOutput_e_unknown
    
    e_failed = _Box2D.b2TOIOutput_e_failed
    
    e_overlapped = _Box2D.b2TOIOutput_e_overlapped
    
    e_touching = _Box2D.b2TOIOutput_e_touching
    
    e_separated = _Box2D.b2TOIOutput_e_separated
    
    state = property(_Box2D.b2TOIOutput_state_get, _Box2D.b2TOIOutput_state_set, doc=r"""state : b2TOIOutput::State""")
    t = property(_Box2D.b2TOIOutput_t_get, _Box2D.b2TOIOutput_t_set, doc=r"""t : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2TOIOutput___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self):
        r"""__init__(b2TOIOutput self) -> b2TOIOutput"""
        _Box2D.b2TOIOutput_swiginit(self, _Box2D.new_b2TOIOutput())
    __swig_destroy__ = _Box2D.delete_b2TOIOutput

# Register b2TOIOutput in _Box2D:
_Box2D.b2TOIOutput_swigregister(b2TOIOutput)

b2_staticBody = _Box2D.b2_staticBody

b2_kinematicBody = _Box2D.b2_kinematicBody

b2_dynamicBody = _Box2D.b2_dynamicBody

class b2BodyDef(object):
    r"""A body definition holds all the data needed to construct a rigid body. You can safely re-use body definitions. Shapes are added to a body after construction."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2BodyDef_swiginit(self,_Box2D.new_b2BodyDef())
        _init_kwargs(self, **kwargs)


    type = property(_Box2D.b2BodyDef_type_get, _Box2D.b2BodyDef_type_set, doc=r"""type : b2BodyType""")
    position = property(_Box2D.b2BodyDef_position_get, _Box2D.b2BodyDef_position_set, doc=r"""position : b2Vec2""")
    angle = property(_Box2D.b2BodyDef_angle_get, _Box2D.b2BodyDef_angle_set, doc=r"""angle : float32""")
    linearVelocity = property(_Box2D.b2BodyDef_linearVelocity_get, _Box2D.b2BodyDef_linearVelocity_set, doc=r"""linearVelocity : b2Vec2""")
    angularVelocity = property(_Box2D.b2BodyDef_angularVelocity_get, _Box2D.b2BodyDef_angularVelocity_set, doc=r"""angularVelocity : float32""")
    linearDamping = property(_Box2D.b2BodyDef_linearDamping_get, _Box2D.b2BodyDef_linearDamping_set, doc=r"""linearDamping : float32""")
    angularDamping = property(_Box2D.b2BodyDef_angularDamping_get, _Box2D.b2BodyDef_angularDamping_set, doc=r"""angularDamping : float32""")
    allowSleep = property(_Box2D.b2BodyDef_allowSleep_get, _Box2D.b2BodyDef_allowSleep_set, doc=r"""allowSleep : bool""")
    awake = property(_Box2D.b2BodyDef_awake_get, _Box2D.b2BodyDef_awake_set, doc=r"""awake : bool""")
    fixedRotation = property(_Box2D.b2BodyDef_fixedRotation_get, _Box2D.b2BodyDef_fixedRotation_set, doc=r"""fixedRotation : bool""")
    bullet = property(_Box2D.b2BodyDef_bullet_get, _Box2D.b2BodyDef_bullet_set, doc=r"""bullet : bool""")
    active = property(_Box2D.b2BodyDef_active_get, _Box2D.b2BodyDef_active_set, doc=r"""active : bool""")
    gravityScale = property(_Box2D.b2BodyDef_gravityScale_get, _Box2D.b2BodyDef_gravityScale_set, doc=r"""gravityScale : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2BodyDef___hash__)

    def __repr__(self):
        return _format_repr(self) 

    __GetUserData = _swig_new_instance_method(_Box2D.b2BodyDef___GetUserData)
    __SetUserData = _swig_new_instance_method(_Box2D.b2BodyDef___SetUserData)
    ClearUserData = _swig_new_instance_method(_Box2D.b2BodyDef_ClearUserData)

    userData = property(__GetUserData, __SetUserData)
    def __del__(self):
        self.ClearUserData()


    _fixtures = None
    _shapes = None
    _shapeFixture = None

    @property
    def fixtures(self):
        return self._fixtures

    @fixtures.setter
    def fixtures(self, fixtures):
        if isinstance(fixtures, b2FixtureDef):
            self._fixtures = [fixtures]
        else:
            self._fixtures = list(fixtures)

    @property
    def shapes(self):
        return self._shapes

    @shapes.setter
    def shapes(self, shapes):
        if isinstance(shapes, b2Shape):
            self._shapes = [shapes]
        else:
            self._shapes = list(shapes)

    @property
    def shapeFixture(self):
        return self._shapeFixture

    @shapeFixture.setter
    def shapeFixture(self, fixture):
        self._shapeFixture = fixture


    __swig_destroy__ = _Box2D.delete_b2BodyDef

# Register b2BodyDef in _Box2D:
_Box2D.b2BodyDef_swigregister(b2BodyDef)

class b2Body(object):
    r"""A rigid body. These are created via  b2World::CreateBody."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __SetTransform = _swig_new_instance_method(_Box2D.b2Body___SetTransform)
    __GetTransform = _swig_new_instance_method(_Box2D.b2Body___GetTransform)
    __GetPosition = _swig_new_instance_method(_Box2D.b2Body___GetPosition)
    __GetAngle = _swig_new_instance_method(_Box2D.b2Body___GetAngle)
    __GetWorldCenter = _swig_new_instance_method(_Box2D.b2Body___GetWorldCenter)
    __GetLocalCenter = _swig_new_instance_method(_Box2D.b2Body___GetLocalCenter)
    __SetLinearVelocity = _swig_new_instance_method(_Box2D.b2Body___SetLinearVelocity)
    __GetLinearVelocity = _swig_new_instance_method(_Box2D.b2Body___GetLinearVelocity)
    __SetAngularVelocity = _swig_new_instance_method(_Box2D.b2Body___SetAngularVelocity)
    __GetAngularVelocity = _swig_new_instance_method(_Box2D.b2Body___GetAngularVelocity)
    ApplyForce = _swig_new_instance_method(_Box2D.b2Body_ApplyForce)
    ApplyForceToCenter = _swig_new_instance_method(_Box2D.b2Body_ApplyForceToCenter)
    ApplyTorque = _swig_new_instance_method(_Box2D.b2Body_ApplyTorque)
    ApplyLinearImpulse = _swig_new_instance_method(_Box2D.b2Body_ApplyLinearImpulse)
    ApplyAngularImpulse = _swig_new_instance_method(_Box2D.b2Body_ApplyAngularImpulse)
    __GetMass = _swig_new_instance_method(_Box2D.b2Body___GetMass)
    __GetInertia = _swig_new_instance_method(_Box2D.b2Body___GetInertia)
    GetMassData = _swig_new_instance_method(_Box2D.b2Body_GetMassData)
    __SetMassData = _swig_new_instance_method(_Box2D.b2Body___SetMassData)
    ResetMassData = _swig_new_instance_method(_Box2D.b2Body_ResetMassData)
    GetWorldPoint = _swig_new_instance_method(_Box2D.b2Body_GetWorldPoint)
    GetWorldVector = _swig_new_instance_method(_Box2D.b2Body_GetWorldVector)
    GetLocalPoint = _swig_new_instance_method(_Box2D.b2Body_GetLocalPoint)
    GetLocalVector = _swig_new_instance_method(_Box2D.b2Body_GetLocalVector)
    GetLinearVelocityFromWorldPoint = _swig_new_instance_method(_Box2D.b2Body_GetLinearVelocityFromWorldPoint)
    GetLinearVelocityFromLocalPoint = _swig_new_instance_method(_Box2D.b2Body_GetLinearVelocityFromLocalPoint)
    __GetLinearDamping = _swig_new_instance_method(_Box2D.b2Body___GetLinearDamping)
    __SetLinearDamping = _swig_new_instance_method(_Box2D.b2Body___SetLinearDamping)
    __GetAngularDamping = _swig_new_instance_method(_Box2D.b2Body___GetAngularDamping)
    __SetAngularDamping = _swig_new_instance_method(_Box2D.b2Body___SetAngularDamping)
    __GetGravityScale = _swig_new_instance_method(_Box2D.b2Body___GetGravityScale)
    __SetGravityScale = _swig_new_instance_method(_Box2D.b2Body___SetGravityScale)
    __SetType = _swig_new_instance_method(_Box2D.b2Body___SetType)
    __GetType = _swig_new_instance_method(_Box2D.b2Body___GetType)
    __SetBullet = _swig_new_instance_method(_Box2D.b2Body___SetBullet)
    __IsBullet = _swig_new_instance_method(_Box2D.b2Body___IsBullet)
    __SetSleepingAllowed = _swig_new_instance_method(_Box2D.b2Body___SetSleepingAllowed)
    __IsSleepingAllowed = _swig_new_instance_method(_Box2D.b2Body___IsSleepingAllowed)
    __SetAwake = _swig_new_instance_method(_Box2D.b2Body___SetAwake)
    __IsAwake = _swig_new_instance_method(_Box2D.b2Body___IsAwake)
    __SetActive = _swig_new_instance_method(_Box2D.b2Body___SetActive)
    __IsActive = _swig_new_instance_method(_Box2D.b2Body___IsActive)
    __SetFixedRotation = _swig_new_instance_method(_Box2D.b2Body___SetFixedRotation)
    __IsFixedRotation = _swig_new_instance_method(_Box2D.b2Body___IsFixedRotation)
    __GetFixtureList_internal = _swig_new_instance_method(_Box2D.b2Body___GetFixtureList_internal)
    __GetJointList_internal = _swig_new_instance_method(_Box2D.b2Body___GetJointList_internal)
    __GetContactList_internal = _swig_new_instance_method(_Box2D.b2Body___GetContactList_internal)
    __GetNext = _swig_new_instance_method(_Box2D.b2Body___GetNext)
    __GetWorld = _swig_new_instance_method(_Box2D.b2Body___GetWorld)
    Dump = _swig_new_instance_method(_Box2D.b2Body_Dump)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Body___hash__)

    def __repr__(self):
        return _format_repr(self) 

    DestroyFixture = _swig_new_instance_method(_Box2D.b2Body_DestroyFixture)
    __CreateFixture = _swig_new_instance_method(_Box2D.b2Body___CreateFixture)
    __GetUserData = _swig_new_instance_method(_Box2D.b2Body___GetUserData)
    __SetUserData = _swig_new_instance_method(_Box2D.b2Body___SetUserData)
    ClearUserData = _swig_new_instance_method(_Box2D.b2Body_ClearUserData)

    userData = property(__GetUserData, __SetUserData)


    __eq__ = b2BodyCompare
    __ne__ = lambda self,other: not b2BodyCompare(self,other)
    def __GetMassData(self):
        """
        Get a b2MassData object that represents this b2Body

        NOTE: To just get the mass, use body.mass
        """
        ret = b2MassData()
        ret.center=self.localCenter
        ret.I    = self.inertia
        ret.mass = self.mass
        return ret

    def __SetInertia(self, inertia):
        """
        Set the body's inertia
        """
        md = self.massData
        md.I = inertia
        self.massData=md

    def __SetMass(self, mass):
        """
        Set the body's mass
        """
        md = self.massData
        md.mass = mass
        self.massData=md

    def __SetLocalCenter(self, lcenter):
        """
        Set the body's local center
        """
        md = self.massData
        md.center = lcenter
        self.massData=md

    def __iter__(self):
        """
        Iterates over the fixtures in the body
        """
        for fixture in self.fixtures:
            yield fixture

    def __CreateShapeFixture(self, type_, **kwargs):
        """
        Internal function to handle creating circles, polygons, etc.
        without first creating a fixture. type_ is b2Shape.
        """
        shape=type_()
        fixture=b2FixtureDef(shape=shape)

        for key, value in kwargs.items():
    # Note that these hasattrs use the types to get around
    # the fact that some properties are write-only (like 'box' in
    # polygon shapes), and as such do not show up with 'hasattr'.
            if hasattr(type_, key):
                to_set=shape
            elif hasattr(b2FixtureDef, key):
                to_set=fixture
            else:
                raise AttributeError('Property %s not found in either %s or b2FixtureDef' % (key, type_.__name__))

            try:
                setattr(to_set, key, value)
            except Exception as ex:
                raise ex.__class__('Failed on kwargs, class="%s" key="%s": %s' \
                            % (to_set.__class__.__name__, key, ex))

        return self.CreateFixture(fixture)

    def CreatePolygonFixture(self, **kwargs):
        """
        Create a polygon shape without an explicit fixture definition.

        Takes kwargs; you can pass in properties for either the polygon
        or the fixture to this function. For example:
        CreatePolygonFixture(box=(1, 1), friction=0.2, density=1.0)
        where 'box' is a property from the polygon shape, and 
        'friction' and 'density' are from the fixture definition.
        """
        return self.__CreateShapeFixture(b2PolygonShape, **kwargs)

    def CreateCircleFixture(self, **kwargs):
        """
        Create a circle shape without an explicit fixture definition.

        Takes kwargs; you can pass in properties for either the circle
        or the fixture to this function. For example:
        CreateCircleFixture(radius=0.2, friction=0.2, density=1.0)
        where 'radius' is a property from the circle shape, and 
        'friction' and 'density' are from the fixture definition.
        """
        return self.__CreateShapeFixture(b2CircleShape, **kwargs)

    def CreateEdgeFixture(self, **kwargs):
        """
        Create a edge shape without an explicit fixture definition.

        Takes kwargs; you can pass in properties for either the edge
        or the fixture to this function. For example:
        CreateEdgeFixture(vertices=[(0,0),(1,0)], friction=0.2, density=1.0)
        where 'vertices' is a property from the edge shape, and 
        'friction' and 'density' are from the fixture definition.
        """
        return self.__CreateShapeFixture(b2EdgeShape, **kwargs)

    def CreateLoopFixture(self, **kwargs):
        """
        Create a loop shape without an explicit fixture definition.

        Takes kwargs; you can pass in properties for either the loop
        or the fixture to this function. For example:
        CreateLoopFixture(vertices=[...], friction=0.2, density=1.0)
        where 'vertices' is a property from the loop shape, and 
        'friction' and 'density' are from the fixture definition.
        """
        return self.__CreateShapeFixture(b2ChainShape, **kwargs)

    CreateChainFixture = CreateLoopFixture

    def CreateFixturesFromShapes(self, shapes=None, shapeFixture=None):
        """
        Create fixture(s) on the body from one or more shapes, and optionally a single
        fixture definition.

        Takes kwargs; examples of valid combinations are as follows:
        CreateFixturesFromShapes(shapes=b2CircleShape(radius=0.2))
        CreateFixturesFromShapes(shapes=b2CircleShape(radius=0.2), shapeFixture=b2FixtureDef(friction=0.2))
        CreateFixturesFromShapes(shapes=[b2CircleShape(radius=0.2), b2PolygonShape(box=[1,2])])
        """
        if shapes==None:
            raise TypeError('At least one shape required')

        if shapeFixture==None:
            shapeFixture=b2FixtureDef()
            oldShape=None
        else:
            oldShape = shapeFixture.shape

        ret=None
        try:
            if isinstance(shapes, (list, tuple)):
                ret = []
                for shape in shapes:
                    shapeFixture.shape = shape
                    ret.append(self.__CreateFixture(shapeFixture))
            else:
                shapeFixture.shape=shapes
                ret = self.__CreateFixture(shapeFixture)
        finally:
            shapeFixture.shape=oldShape

        return ret

    def CreateFixture(self, defn=None, **kwargs):
        """
        Create a fixtures on the body.

        Takes kwargs; examples of valid combinations are as follows:
        CreateFixture(b2FixtureDef(shape=s, restitution=0.2, ...))
        CreateFixture(shape=s, restitution=0.2, ...)
        """
        if defn is not None and isinstance(defn, b2FixtureDef):
            return self.__CreateFixture(defn)
        else:
            if 'shape' not in kwargs:
                raise ValueError('Must specify the shape for the fixture')
            return self.__CreateFixture(b2FixtureDef(**kwargs))

    def CreateEdgeChain(self, edge_list):
        """
        Creates a body a set of connected edge chains.
        Expects edge_list to be a list of vertices, length >= 2.
        """
        prev=None
        if len(edge_list) < 2:
            raise ValueError('Edge list length >= 2')

        shape=b2EdgeShape(vertices=[list(i) for i in edge_list[0:2]])
        self.CreateFixturesFromShapes(shape)

        prev = edge_list[1]
        for edge in edge_list[1:]:
            if len(edge) != 2:
                raise ValueError('Vertex length != 2, "%s"' % list(edge))
            shape.vertices = [list(prev), list(edge)]
            self.CreateFixturesFromShapes(shape)
            prev=edge

    # Read-write properties
    sleepingAllowed = property(__IsSleepingAllowed, __SetSleepingAllowed)
    angularVelocity = property(__GetAngularVelocity, __SetAngularVelocity)
    linearVelocity = property(__GetLinearVelocity, __SetLinearVelocity)
    awake = property(__IsAwake, __SetAwake)
    angularDamping = property(__GetAngularDamping, __SetAngularDamping)
    fixedRotation = property(__IsFixedRotation, __SetFixedRotation)
    linearDamping = property(__GetLinearDamping, __SetLinearDamping)
    bullet = property(__IsBullet, __SetBullet)
    type = property(__GetType, __SetType)
    active = property(__IsActive, __SetActive)
    angle = property(__GetAngle, lambda self, angle: self.__SetTransform(self.position, angle))
    transform = property(__GetTransform, lambda self, value: self.__SetTransform(*value))
    massData = property(__GetMassData, __SetMassData)
    mass = property(__GetMass, __SetMass)
    localCenter = property(__GetLocalCenter, __SetLocalCenter)
    inertia = property(__GetInertia, __SetInertia)
    position = property(__GetPosition, lambda self, pos: self.__SetTransform(pos, self.angle))
    gravityScale = property(__GetGravityScale, __SetGravityScale)

    # Read-only
    joints = property(lambda self: _list_from_linked_list(self.__GetJointList_internal()), None, 
                        doc="""All joints connected to the body as a list. 
                        NOTE: This re-creates the list on every call. See also joints_gen.""")
    contacts = property(lambda self: _list_from_linked_list(self.__GetContactList_internal()), None,
                        doc="""All contacts related to the body as a list. 
                        NOTE: This re-creates the list on every call. See also contacts_gen.""")
    fixtures = property(lambda self: _list_from_linked_list(self.__GetFixtureList_internal()), None,
                        doc="""All fixtures contained in this body as a list. 
                        NOTE: This re-creates the list on every call. See also fixtures_gen.""")
    joints_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetJointList_internal())), None,
                        doc="""Indexable generator of the connected joints to this body.
                        NOTE: When not using the whole list, this may be preferable to using 'joints'.""")
    contacts_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetContactList_internal())), None,
                        doc="""Indexable generator of the related contacts.
                        NOTE: When not using the whole list, this may be preferable to using 'contacts'.""")
    fixtures_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetFixtureList_internal())), None,
                        doc="""Indexable generator of the contained fixtures.
                        NOTE: When not using the whole list, this may be preferable to using 'fixtures'.""")
    next = property(__GetNext, None)
    worldCenter = property(__GetWorldCenter, None)
    world = property(__GetWorld, None)



# Register b2Body in _Box2D:
_Box2D.b2Body_swigregister(b2Body)

class b2Filter(object):
    r"""This holds contact filtering data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2Filter_swiginit(self,_Box2D.new_b2Filter())
        _init_kwargs(self, **kwargs)


    categoryBits = property(_Box2D.b2Filter_categoryBits_get, _Box2D.b2Filter_categoryBits_set, doc=r"""categoryBits : uint16""")
    maskBits = property(_Box2D.b2Filter_maskBits_get, _Box2D.b2Filter_maskBits_set, doc=r"""maskBits : uint16""")
    groupIndex = property(_Box2D.b2Filter_groupIndex_get, _Box2D.b2Filter_groupIndex_set, doc=r"""groupIndex : int16""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Filter___hash__)

    def __repr__(self):
        return _format_repr(self) 

    __swig_destroy__ = _Box2D.delete_b2Filter

# Register b2Filter in _Box2D:
_Box2D.b2Filter_swigregister(b2Filter)

class b2FixtureDef(object):
    r"""A fixture definition is used to create a fixture. This class defines an abstract fixture definition. You can reuse fixture definitions safely."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2FixtureDef_swiginit(self,_Box2D.new_b2FixtureDef())
        _init_kwargs(self, **kwargs)


    shape = property(_Box2D.b2FixtureDef_shape_get, _Box2D.b2FixtureDef_shape_set, doc=r"""shape : p.q(const).b2Shape""")
    friction = property(_Box2D.b2FixtureDef_friction_get, _Box2D.b2FixtureDef_friction_set, doc=r"""friction : float32""")
    restitution = property(_Box2D.b2FixtureDef_restitution_get, _Box2D.b2FixtureDef_restitution_set, doc=r"""restitution : float32""")
    density = property(_Box2D.b2FixtureDef_density_get, _Box2D.b2FixtureDef_density_set, doc=r"""density : float32""")
    isSensor = property(_Box2D.b2FixtureDef_isSensor_get, _Box2D.b2FixtureDef_isSensor_set, doc=r"""isSensor : bool""")
    filter = property(_Box2D.b2FixtureDef_filter_get, _Box2D.b2FixtureDef_filter_set, doc=r"""filter : b2Filter""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2FixtureDef___hash__)

    def __repr__(self):
        return _format_repr(self) 

    __GetUserData = _swig_new_instance_method(_Box2D.b2FixtureDef___GetUserData)
    __SetUserData = _swig_new_instance_method(_Box2D.b2FixtureDef___SetUserData)
    ClearUserData = _swig_new_instance_method(_Box2D.b2FixtureDef_ClearUserData)

    userData = property(__GetUserData, __SetUserData)
    def __del__(self):
        self.ClearUserData()


    def __SetCategoryBits(self, value):
        self.filter.categoryBits=value
    def __SetGroupIndex(self, value):
        self.filter.groupIndex=value
    def __SetMaskBits(self, value):
        self.filter.maskBits=value

    categoryBits=property(lambda self: self.filter.categoryBits, __SetCategoryBits)
    groupIndex=property(lambda self: self.filter.groupIndex, __SetGroupIndex)
    maskBits=property(lambda self: self.filter.maskBits, __SetMaskBits)

    __swig_destroy__ = _Box2D.delete_b2FixtureDef

# Register b2FixtureDef in _Box2D:
_Box2D.b2FixtureDef_swigregister(b2FixtureDef)

class b2FixtureProxy(object):
    r"""This proxy is used internally to connect fixtures to the broad-phase."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    aabb = property(_Box2D.b2FixtureProxy_aabb_get, _Box2D.b2FixtureProxy_aabb_set, doc=r"""aabb : b2AABB""")
    fixture = property(_Box2D.b2FixtureProxy_fixture_get, _Box2D.b2FixtureProxy_fixture_set, doc=r"""fixture : p.b2Fixture""")
    childIndex = property(_Box2D.b2FixtureProxy_childIndex_get, _Box2D.b2FixtureProxy_childIndex_set, doc=r"""childIndex : int32""")
    proxyId = property(_Box2D.b2FixtureProxy_proxyId_get, _Box2D.b2FixtureProxy_proxyId_set, doc=r"""proxyId : int32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2FixtureProxy___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self):
        r"""
        __init__(b2FixtureProxy self) -> b2FixtureProxy
        This proxy is used internally to connect fixtures to the broad-phase.
        """
        _Box2D.b2FixtureProxy_swiginit(self, _Box2D.new_b2FixtureProxy())
    __swig_destroy__ = _Box2D.delete_b2FixtureProxy

# Register b2FixtureProxy in _Box2D:
_Box2D.b2FixtureProxy_swigregister(b2FixtureProxy)

class b2Fixture(object):
    r"""
    A fixture is used to attach a shape to a body for collision detection. A fixture inherits its transform from its parent. Fixtures hold additional non-geometric data such as friction, collision filters, etc. Fixtures are created via  b2Body::CreateFixture. 
    WARNING: 
    you cannot reuse fixtures.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __GetType = _swig_new_instance_method(_Box2D.b2Fixture___GetType)
    __GetShape = _swig_new_instance_method(_Box2D.b2Fixture___GetShape)
    __SetSensor = _swig_new_instance_method(_Box2D.b2Fixture___SetSensor)
    __IsSensor = _swig_new_instance_method(_Box2D.b2Fixture___IsSensor)
    __SetFilterData = _swig_new_instance_method(_Box2D.b2Fixture___SetFilterData)
    __GetFilterData = _swig_new_instance_method(_Box2D.b2Fixture___GetFilterData)
    Refilter = _swig_new_instance_method(_Box2D.b2Fixture_Refilter)
    __GetBody = _swig_new_instance_method(_Box2D.b2Fixture___GetBody)
    __GetNext = _swig_new_instance_method(_Box2D.b2Fixture___GetNext)
    TestPoint = _swig_new_instance_method(_Box2D.b2Fixture_TestPoint)
    RayCast = _swig_new_instance_method(_Box2D.b2Fixture_RayCast)
    __GetMassData = _swig_new_instance_method(_Box2D.b2Fixture___GetMassData)
    __SetDensity = _swig_new_instance_method(_Box2D.b2Fixture___SetDensity)
    __GetDensity = _swig_new_instance_method(_Box2D.b2Fixture___GetDensity)
    __GetFriction = _swig_new_instance_method(_Box2D.b2Fixture___GetFriction)
    __SetFriction = _swig_new_instance_method(_Box2D.b2Fixture___SetFriction)
    __GetRestitution = _swig_new_instance_method(_Box2D.b2Fixture___GetRestitution)
    __SetRestitution = _swig_new_instance_method(_Box2D.b2Fixture___SetRestitution)
    GetAABB = _swig_new_instance_method(_Box2D.b2Fixture_GetAABB)
    Dump = _swig_new_instance_method(_Box2D.b2Fixture_Dump)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Fixture___hash__)

    def __repr__(self):
        return _format_repr(self) 

    __GetUserData = _swig_new_instance_method(_Box2D.b2Fixture___GetUserData)
    __SetUserData = _swig_new_instance_method(_Box2D.b2Fixture___SetUserData)
    ClearUserData = _swig_new_instance_method(_Box2D.b2Fixture_ClearUserData)

    userData = property(__GetUserData, __SetUserData)

    __swig_destroy__ = _Box2D.delete_b2Fixture

    __eq__ = b2FixtureCompare
    __ne__ = lambda self,other: not b2FixtureCompare(self,other)

    # Read-write properties
    friction = property(__GetFriction, __SetFriction)
    restitution = property(__GetRestitution, __SetRestitution)
    filterData = property(__GetFilterData, __SetFilterData)
    sensor = property(__IsSensor, __SetSensor)
    density = property(__GetDensity, __SetDensity)

    # Read-only
    next = property(__GetNext, None)
    type = property(__GetType, None)
    shape = property(__GetShape, None)
    body = property(__GetBody, None)

    @property
    def massData(self):
        md=b2MassData()
        self.__GetMassData(md)
        return md


# Register b2Fixture in _Box2D:
_Box2D.b2Fixture_swigregister(b2Fixture)

class b2DestructionListener(object):
    r"""Joints and fixtures are destroyed when their associated body is destroyed. Implement this listener so that you may nullify references to these joints and shapes."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2DestructionListener
    SayGoodbye = _swig_new_instance_method(_Box2D.b2DestructionListener_SayGoodbye)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2DestructionListener___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        if self.__class__ == b2DestructionListener:
            _self = None
        else:
            _self = self
        _Box2D.b2DestructionListener_swiginit(self,_Box2D.new_b2DestructionListener(_self, ))
        _init_kwargs(self, **kwargs)


    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2DestructionListener(self)
        return weakref.proxy(self)

# Register b2DestructionListener in _Box2D:
_Box2D.b2DestructionListener_swigregister(b2DestructionListener)

class b2ContactFilter(object):
    r"""Implement this class to provide collision filtering. In other words, you can implement this class if you want finer control over contact creation."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2ContactFilter
    ShouldCollide = _swig_new_instance_method(_Box2D.b2ContactFilter_ShouldCollide)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2ContactFilter___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        if self.__class__ == b2ContactFilter:
            _self = None
        else:
            _self = self
        _Box2D.b2ContactFilter_swiginit(self,_Box2D.new_b2ContactFilter(_self, ))
        _init_kwargs(self, **kwargs)


    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2ContactFilter(self)
        return weakref.proxy(self)

# Register b2ContactFilter in _Box2D:
_Box2D.b2ContactFilter_swigregister(b2ContactFilter)

class b2ContactImpulse(object):
    r"""Contact impulses for reporting. Impulses are used instead of forces because sub-step forces may approach infinity for rigid body collisions. These match up one-to-one with the contact points in  b2Manifold."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    count = property(_Box2D.b2ContactImpulse_count_get, _Box2D.b2ContactImpulse_count_set, doc=r"""count : int32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2ContactImpulse___hash__)

    def __repr__(self):
        return _format_repr(self) 

    __get_normal_impulses = _swig_new_instance_method(_Box2D.b2ContactImpulse___get_normal_impulses)
    __get_tangent_impulses = _swig_new_instance_method(_Box2D.b2ContactImpulse___get_tangent_impulses)

    normalImpulses = property(__get_normal_impulses, None)
    tangentImpulses = property(__get_tangent_impulses, None)


    def __init__(self, **kwargs):
        _Box2D.b2ContactImpulse_swiginit(self,_Box2D.new_b2ContactImpulse())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ContactImpulse

# Register b2ContactImpulse in _Box2D:
_Box2D.b2ContactImpulse_swigregister(b2ContactImpulse)

class b2ContactListener(object):
    r"""
    Implement this class to get contact information. You can use these results for things like sounds and game logic. You can also get contact results by traversing the contact lists after the time step. However, you might miss some contacts because continuous physics leads to sub-stepping. Additionally you may receive multiple callbacks for the same contact in a single time step. You should strive to make your callbacks efficient because there may be many callbacks per time step. 
    WARNING: 
    You cannot create/destroy Box2D entities inside these callbacks.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2ContactListener
    BeginContact = _swig_new_instance_method(_Box2D.b2ContactListener_BeginContact)
    EndContact = _swig_new_instance_method(_Box2D.b2ContactListener_EndContact)
    PreSolve = _swig_new_instance_method(_Box2D.b2ContactListener_PreSolve)
    PostSolve = _swig_new_instance_method(_Box2D.b2ContactListener_PostSolve)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2ContactListener___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        if self.__class__ == b2ContactListener:
            _self = None
        else:
            _self = self
        _Box2D.b2ContactListener_swiginit(self,_Box2D.new_b2ContactListener(_self, ))
        _init_kwargs(self, **kwargs)


    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2ContactListener(self)
        return weakref.proxy(self)

# Register b2ContactListener in _Box2D:
_Box2D.b2ContactListener_swigregister(b2ContactListener)

class b2QueryCallback(object):
    r"""Callback class for AABB queries. See b2World::Query"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2QueryCallback
    ReportFixture = _swig_new_instance_method(_Box2D.b2QueryCallback_ReportFixture)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2QueryCallback___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        if self.__class__ == b2QueryCallback:
            _self = None
        else:
            _self = self
        _Box2D.b2QueryCallback_swiginit(self,_Box2D.new_b2QueryCallback(_self, ))
        _init_kwargs(self, **kwargs)


    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2QueryCallback(self)
        return weakref.proxy(self)

# Register b2QueryCallback in _Box2D:
_Box2D.b2QueryCallback_swigregister(b2QueryCallback)

class b2RayCastCallback(object):
    r"""Callback class for ray casts. See  b2World::RayCast"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2RayCastCallback
    ReportFixture = _swig_new_instance_method(_Box2D.b2RayCastCallback_ReportFixture)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2RayCastCallback___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self):
        r"""
        __init__(b2RayCastCallback self) -> b2RayCastCallback
        Callback class for ray casts. See  b2World::RayCast
        """
        if self.__class__ == b2RayCastCallback:
            _self = None
        else:
            _self = self
        _Box2D.b2RayCastCallback_swiginit(self, _Box2D.new_b2RayCastCallback(_self, ))
    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2RayCastCallback(self)
        return weakref.proxy(self)

# Register b2RayCastCallback in _Box2D:
_Box2D.b2RayCastCallback_swigregister(b2RayCastCallback)

class b2Profile(object):
    r"""Proxy of C++ b2Profile class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    step = property(_Box2D.b2Profile_step_get, _Box2D.b2Profile_step_set, doc=r"""step : float32""")
    collide = property(_Box2D.b2Profile_collide_get, _Box2D.b2Profile_collide_set, doc=r"""collide : float32""")
    solve = property(_Box2D.b2Profile_solve_get, _Box2D.b2Profile_solve_set, doc=r"""solve : float32""")
    solveInit = property(_Box2D.b2Profile_solveInit_get, _Box2D.b2Profile_solveInit_set, doc=r"""solveInit : float32""")
    solveVelocity = property(_Box2D.b2Profile_solveVelocity_get, _Box2D.b2Profile_solveVelocity_set, doc=r"""solveVelocity : float32""")
    solvePosition = property(_Box2D.b2Profile_solvePosition_get, _Box2D.b2Profile_solvePosition_set, doc=r"""solvePosition : float32""")
    broadphase = property(_Box2D.b2Profile_broadphase_get, _Box2D.b2Profile_broadphase_set, doc=r"""broadphase : float32""")
    solveTOI = property(_Box2D.b2Profile_solveTOI_get, _Box2D.b2Profile_solveTOI_set, doc=r"""solveTOI : float32""")

    def __init__(self):
        r"""__init__(b2Profile self) -> b2Profile"""
        _Box2D.b2Profile_swiginit(self, _Box2D.new_b2Profile())
    __swig_destroy__ = _Box2D.delete_b2Profile

# Register b2Profile in _Box2D:
_Box2D.b2Profile_swigregister(b2Profile)

class b2SolverData(object):
    r"""Proxy of C++ b2SolverData class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    step = property(_Box2D.b2SolverData_step_get, _Box2D.b2SolverData_step_set, doc=r"""step : b2TimeStep""")
    positions = property(_Box2D.b2SolverData_positions_get, _Box2D.b2SolverData_positions_set, doc=r"""positions : p.b2Position""")
    velocities = property(_Box2D.b2SolverData_velocities_get, _Box2D.b2SolverData_velocities_set, doc=r"""velocities : p.b2Velocity""")

    def __init__(self):
        r"""__init__(b2SolverData self) -> b2SolverData"""
        _Box2D.b2SolverData_swiginit(self, _Box2D.new_b2SolverData())
    __swig_destroy__ = _Box2D.delete_b2SolverData

# Register b2SolverData in _Box2D:
_Box2D.b2SolverData_swigregister(b2SolverData)

class b2ContactManager(object):
    r"""Proxy of C++ b2ContactManager class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(b2ContactManager self) -> b2ContactManager"""
        _Box2D.b2ContactManager_swiginit(self, _Box2D.new_b2ContactManager())
    AddPair = _swig_new_instance_method(_Box2D.b2ContactManager_AddPair)
    FindNewContacts = _swig_new_instance_method(_Box2D.b2ContactManager_FindNewContacts)
    Destroy = _swig_new_instance_method(_Box2D.b2ContactManager_Destroy)
    Collide = _swig_new_instance_method(_Box2D.b2ContactManager_Collide)
    broadPhase = property(_Box2D.b2ContactManager_broadPhase_get, _Box2D.b2ContactManager_broadPhase_set, doc=r"""broadPhase : b2BroadPhase""")
    contactList = property(_Box2D.b2ContactManager_contactList_get, _Box2D.b2ContactManager_contactList_set, doc=r"""contactList : p.b2Contact""")
    contactCount = property(_Box2D.b2ContactManager_contactCount_get, _Box2D.b2ContactManager_contactCount_set, doc=r"""contactCount : int32""")
    contactFilter = property(_Box2D.b2ContactManager_contactFilter_get, _Box2D.b2ContactManager_contactFilter_set, doc=r"""contactFilter : p.b2ContactFilter""")
    contactListener = property(_Box2D.b2ContactManager_contactListener_get, _Box2D.b2ContactManager_contactListener_set, doc=r"""contactListener : p.b2ContactListener""")
    allocator = property(_Box2D.b2ContactManager_allocator_get, _Box2D.b2ContactManager_allocator_set, doc=r"""allocator : p.b2BlockAllocator""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2ContactManager___hash__)

    def __repr__(self):
        return _format_repr(self) 



    __swig_destroy__ = _Box2D.delete_b2ContactManager

# Register b2ContactManager in _Box2D:
_Box2D.b2ContactManager_swigregister(b2ContactManager)
b2_stackSize = b2Globals.b2_stackSize
b2_maxStackEntries = b2Globals.b2_maxStackEntries

class b2World(object):
    r"""The world class manages all physics entities, dynamic simulation, and asynchronous queries. The world also contains efficient memory management facilities."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, gravity=(0, -10), doSleep=True, **kwargs): 
        """__init__(self, gravity=(0, -10), doSleep=True, **kwargs) -> b2World

        Additional kwargs like contactListener will be passed after the world is created.

        Examples:
         b2World(gravity=(0,-10), doSleep=True)
         b2World(contactListener=myListener)
        """
        _Box2D.b2World_swiginit(self,_Box2D.new_b2World(gravity))

        self.allowSleeping = doSleep

        for key, value in kwargs.items():
            try:
                setattr(self, key, value)
            except Exception as ex:
                raise ex.__class__('Failed on kwargs, class="%s" key="%s": %s' \
                            % (self.__class__.__name__, key, ex))


    __swig_destroy__ = _Box2D.delete_b2World
    __SetDestructionListener_internal = _swig_new_instance_method(_Box2D.b2World___SetDestructionListener_internal)
    __SetContactFilter_internal = _swig_new_instance_method(_Box2D.b2World___SetContactFilter_internal)
    __SetContactListener_internal = _swig_new_instance_method(_Box2D.b2World___SetContactListener_internal)
    __SetDebugDraw_internal = _swig_new_instance_method(_Box2D.b2World___SetDebugDraw_internal)
    Step = _swig_new_instance_method(_Box2D.b2World_Step)
    ClearForces = _swig_new_instance_method(_Box2D.b2World_ClearForces)
    DrawDebugData = _swig_new_instance_method(_Box2D.b2World_DrawDebugData)
    QueryAABB = _swig_new_instance_method(_Box2D.b2World_QueryAABB)
    RayCast = _swig_new_instance_method(_Box2D.b2World_RayCast)
    __GetBodyList_internal = _swig_new_instance_method(_Box2D.b2World___GetBodyList_internal)
    __GetJointList_internal = _swig_new_instance_method(_Box2D.b2World___GetJointList_internal)
    __GetContactList_internal = _swig_new_instance_method(_Box2D.b2World___GetContactList_internal)
    SetAllowSleeping = _swig_new_instance_method(_Box2D.b2World_SetAllowSleeping)
    GetAllowSleeping = _swig_new_instance_method(_Box2D.b2World_GetAllowSleeping)
    __SetWarmStarting = _swig_new_instance_method(_Box2D.b2World___SetWarmStarting)
    __GetWarmStarting = _swig_new_instance_method(_Box2D.b2World___GetWarmStarting)
    __SetContinuousPhysics = _swig_new_instance_method(_Box2D.b2World___SetContinuousPhysics)
    __GetContinuousPhysics = _swig_new_instance_method(_Box2D.b2World___GetContinuousPhysics)
    __SetSubStepping = _swig_new_instance_method(_Box2D.b2World___SetSubStepping)
    __GetSubStepping = _swig_new_instance_method(_Box2D.b2World___GetSubStepping)
    __GetProxyCount = _swig_new_instance_method(_Box2D.b2World___GetProxyCount)
    __GetBodyCount = _swig_new_instance_method(_Box2D.b2World___GetBodyCount)
    __GetJointCount = _swig_new_instance_method(_Box2D.b2World___GetJointCount)
    __GetContactCount = _swig_new_instance_method(_Box2D.b2World___GetContactCount)
    GetTreeHeight = _swig_new_instance_method(_Box2D.b2World_GetTreeHeight)
    GetTreeBalance = _swig_new_instance_method(_Box2D.b2World_GetTreeBalance)
    GetTreeQuality = _swig_new_instance_method(_Box2D.b2World_GetTreeQuality)
    __SetGravity = _swig_new_instance_method(_Box2D.b2World___SetGravity)
    __GetGravity = _swig_new_instance_method(_Box2D.b2World___GetGravity)
    __IsLocked = _swig_new_instance_method(_Box2D.b2World___IsLocked)
    __SetAutoClearForces = _swig_new_instance_method(_Box2D.b2World___SetAutoClearForces)
    __GetAutoClearForces = _swig_new_instance_method(_Box2D.b2World___GetAutoClearForces)
    ShiftOrigin = _swig_new_instance_method(_Box2D.b2World_ShiftOrigin)
    __GetContactManager = _swig_new_instance_method(_Box2D.b2World___GetContactManager)
    GetProfile = _swig_new_instance_method(_Box2D.b2World_GetProfile)
    Dump = _swig_new_instance_method(_Box2D.b2World_Dump)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2World___hash__)

    def __repr__(self):
        return _format_repr(self) 

    __CreateBody = _swig_new_instance_method(_Box2D.b2World___CreateBody)
    __CreateJoint = _swig_new_instance_method(_Box2D.b2World___CreateJoint)
    DestroyBody = _swig_new_instance_method(_Box2D.b2World_DestroyBody)
    DestroyJoint = _swig_new_instance_method(_Box2D.b2World_DestroyJoint)

    def __iter__(self):
        """
        Iterates over the bodies in the world
        """
        for body in self.bodies:
            yield body

    def CreateDynamicBody(self, **kwargs):
        """
        Create a single dynamic body in the world.

        Accepts only kwargs to a b2BodyDef. For more information, see
        CreateBody and b2BodyDef.
        """
        kwargs['type'] = b2_dynamicBody
        return self.CreateBody(**kwargs)

    def CreateKinematicBody(self, **kwargs):
        """
        Create a single kinematic body in the world.

        Accepts only kwargs to a b2BodyDef. For more information, see
        CreateBody and b2BodyDef.
        """
        kwargs['type'] = b2_kinematicBody
        return self.CreateBody(**kwargs)

    def CreateStaticBody(self, **kwargs):
        """
        Create a single static body in the world.

        Accepts only kwargs to a b2BodyDef. For more information, see
        CreateBody and b2BodyDef.
        """
        kwargs['type'] = b2_staticBody
        return self.CreateBody(**kwargs)

    def CreateBody(self, defn=None, **kwargs):
        """
        Create a body in the world.
        Takes a single b2BodyDef argument, or kwargs to pass to a temporary b2BodyDef.
        world.CreateBody(position=(1,2), angle=1) 
        is short for:
        world.CreateBody(b2BodyDef(position=(1,2), angle=1))

        If the definition (or kwargs) sets 'fixtures', they will be created on the 
        newly created body. A single fixture is also accepted.

        CreateBody(..., fixtures=[])

        This is short for:
            body = CreateBody(...)
            for fixture in []:
                body.CreateFixture(fixture)

         'shapes' and 'shapeFixture' are also accepted:
         CreateBody(..., shapes=[], shapeFixture=b2FixtureDef())

        This is short for:
            body = CreateBody(...)
            body.CreateFixturesFromShapes(shapes=[], shapeFixture=b2FixtureDef())
        """
        if defn is not None:
            if not isinstance(defn, b2BodyDef):
                raise TypeError('Expected b2BodyDef')
        else:
            defn = b2BodyDef(**kwargs) 

        body=self.__CreateBody(defn)

        if defn.fixtures:
            if isinstance(defn.fixtures, (list, tuple)):
                for fixture in defn.fixtures:
                    body.CreateFixture(fixture)
            else:
                body.CreateFixture(defn.fixtures)
        if defn.shapes:
            body.CreateFixturesFromShapes(shapes=defn.shapes, shapeFixture=defn.shapeFixture)

        if 'massData' in kwargs:
            body.massData=kwargs['massData']
        if 'localCenter' in kwargs:
            body.localCenter=kwargs['localCenter']
        if 'inertia' in kwargs:
            body.inertia=kwargs['inertia']
        if 'mass' in kwargs:
            body.mass=kwargs['mass']

        return body

    def CreateDistanceJoint(self, **kwargs):
        """
        Create a single b2DistanceJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2DistanceJointDef(**kwargs))

    def CreateRopeJoint(self, **kwargs):
        """
        Create a single b2RopeJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2RopeJointDef(**kwargs))

    def CreateFrictionJoint(self, **kwargs):
        """
        Create a single b2FrictionJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2FrictionJointDef(**kwargs))

    def CreateGearJoint(self, **kwargs):
        """
        Create a single b2GearJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either joint1 or joint2 is left unset.
        """
        if 'joint1' not in kwargs or 'joint2' not in kwargs:
            raise ValueError('Gear joint requires that both joint1 and joint2 be set')
        return self.__CreateJoint(b2GearJointDef(**kwargs))

    def CreateWheelJoint(self, **kwargs):
        """
        Create a single b2WheelJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2WheelJointDef(**kwargs))

    def CreateMouseJoint(self, **kwargs):
        """
        Create a single b2MouseJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2MouseJointDef(**kwargs))

    def CreatePrismaticJoint(self, **kwargs):
        """
        Create a single b2PrismaticJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2PrismaticJointDef(**kwargs))

    def CreatePulleyJoint(self, **kwargs):
        """
        Create a single b2PulleyJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2PulleyJointDef(**kwargs))

    def CreateRevoluteJoint(self, **kwargs):
        """
        Create a single b2RevoluteJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2RevoluteJointDef(**kwargs))

    def CreateWeldJoint(self, **kwargs):
        """
        Create a single b2WeldJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2WeldJointDef(**kwargs))

    def CreateMotorJoint(self, **kwargs):
        """
        Create a single b2MotorJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2MotorJointDef(**kwargs))

    def CreateJoint(self, defn=None, type=None, **kwargs):
        """
        Create a joint in the world.
        Takes a single b2JointDef argument, or kwargs to pass to a temporary b2JointDef.

        All of these are exactly equivalent:
        world.CreateJoint(type=b2RevoluteJoint, bodyA=body, bodyB=body2)
        world.CreateJoint(type=b2RevoluteJointDef, bodyA=body, bodyB=body2)
        world.CreateJoint(b2RevoluteJointDef(bodyA=body, bodyB=body2))
        """
        if defn is not None:
            if not isinstance(defn, b2JointDef):
                raise TypeError('Expected b2JointDef')
            if defn.bodyA is None or defn.bodyB is None:
                raise ValueError('bodyA and bodyB must be set')
        else:
            if type is not None:
                if issubclass(type, b2JointDef):
                    class_type = type
                elif issubclass(type, b2Joint):  # a b2Joint passed in, so get the b2JointDef
                    class_type = globals()[type.__name__ + 'Def']
                else:
                    raise TypeError('Expected "type" to be a b2Joint or b2JointDef')
            else:
                raise TypeError('Expected "type" to be a b2Joint or b2JointDef')

            defn = class_type(**kwargs) 

        if isinstance(defn, b2GearJointDef):
            if not defn.joint1 or not defn.joint2:
                raise ValueError('Gear joint requires that both joint1 and joint2 be set')
        else:
            if not defn.bodyA or not defn.bodyB:
                raise ValueError('Body or bodies not set (bodyA, bodyB)')

        return self.__CreateJoint(defn)

    # The logic behind these functions is that they increase the refcount
    # of the listeners as you set them, so it is no longer necessary to keep
    # a copy on your own. Upon destruction of the object, it should be cleared
    # also clearing the refcount of the function.
    # Now using it also to buffer previously write-only values in the shadowed
    # class to make them read-write.
    def __GetData(self, name):
        if name in list(self.__data.keys()):
            return self.__data[name]
        else:
            return None
    def __SetData(self, name, value, fcn):
        self.__data[name] = value
        fcn(value)

    # Read-write properties
    gravity   = property(__GetGravity, __SetGravity)
    autoClearForces = property(__GetAutoClearForces, __SetAutoClearForces)
    __data = {} # holds the listeners so they can be properly destroyed, and buffer other data
    destructionListener = property(lambda self: self.__GetData('destruction'), 
                                   lambda self, fcn: self.__SetData('destruction', fcn, self.__SetDestructionListener_internal))
    contactListener= property(lambda self: self.__GetData('contact'), 
                              lambda self, fcn: self.__SetData('contact', fcn, self.__SetContactListener_internal))
    contactFilter= property(lambda self: self.__GetData('contactfilter'),
                            lambda self, fcn: self.__SetData('contactfilter', fcn, self.__SetContactFilter_internal))
    renderer= property(lambda self: self.__GetData('renderer'),
                        lambda self, fcn: self.__SetData('renderer', fcn, self.__SetDebugDraw_internal))

    continuousPhysics = property(__GetContinuousPhysics, __SetContinuousPhysics)
    warmStarting = property(__GetWarmStarting, __SetWarmStarting)
    subStepping = property(__GetSubStepping, __SetSubStepping)

    # Read-only 
    contactManager= property(__GetContactManager, None)
    contactCount  = property(__GetContactCount, None)
    bodyCount     = property(__GetBodyCount, None)
    jointCount    = property(__GetJointCount, None)
    proxyCount    = property(__GetProxyCount, None)
    joints  = property(lambda self: _list_from_linked_list(self.__GetJointList_internal()), None,
                        doc="""All joints in the world.  NOTE: This re-creates the list on every call. See also joints_gen.""")
    bodies  = property(lambda self: _list_from_linked_list(self.__GetBodyList_internal()), None,
                        doc="""All bodies in the world.  NOTE: This re-creates the list on every call. See also bodies_gen.""")
    contacts= property(lambda self: _list_from_linked_list(self.__GetContactList_internal()), None,
                        doc="""All contacts in the world.  NOTE: This re-creates the list on every call. See also contacts_gen.""")
    joints_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetJointList_internal())), None,
                        doc="""Indexable generator of the connected joints to this body.
                        NOTE: When not using the whole list, this may be preferable to using 'joints'.""")
    bodies_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetBodyList_internal())), None,
                        doc="""Indexable generator of all bodies.
                        NOTE: When not using the whole list, this may be preferable to using 'bodies'.""")
    contacts_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetContactList_internal())), None,
                        doc="""Indexable generator of all contacts.
                        NOTE: When not using the whole list, this may be preferable to using 'contacts'.""")
    locked  = property(__IsLocked, None)



# Register b2World in _Box2D:
_Box2D.b2World_swigregister(b2World)

b2MixFriction = _Box2D.b2MixFriction
b2MixRestitution = _Box2D.b2MixRestitution
class b2ContactEdge(object):
    r"""A contact edge is used to connect bodies and contacts together in a contact graph where each body is a node and each contact is an edge. A contact edge belongs to a doubly linked list maintained in each attached body. Each contact has two contact nodes, one for each attached body."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    other = property(_Box2D.b2ContactEdge_other_get, _Box2D.b2ContactEdge_other_set, doc=r"""other : p.b2Body""")
    contact = property(_Box2D.b2ContactEdge_contact_get, _Box2D.b2ContactEdge_contact_set, doc=r"""contact : p.b2Contact""")
    prev = property(_Box2D.b2ContactEdge_prev_get, _Box2D.b2ContactEdge_prev_set, doc=r"""prev : p.b2ContactEdge""")
    next = property(_Box2D.b2ContactEdge_next_get, _Box2D.b2ContactEdge_next_set, doc=r"""next : p.b2ContactEdge""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2ContactEdge___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2ContactEdge_swiginit(self,_Box2D.new_b2ContactEdge())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ContactEdge

# Register b2ContactEdge in _Box2D:
_Box2D.b2ContactEdge_swigregister(b2ContactEdge)

class b2Contact(object):
    r"""The class manages contact between two shapes. A contact exists for each overlapping AABB in the broad-phase (except if filtered). Therefore a contact object may exist that has no contact points."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __GetManifold = _swig_new_instance_method(_Box2D.b2Contact___GetManifold)
    __GetWorldManifold_internal = _swig_new_instance_method(_Box2D.b2Contact___GetWorldManifold_internal)
    __IsTouching = _swig_new_instance_method(_Box2D.b2Contact___IsTouching)
    __SetEnabled = _swig_new_instance_method(_Box2D.b2Contact___SetEnabled)
    __IsEnabled = _swig_new_instance_method(_Box2D.b2Contact___IsEnabled)
    __GetNext = _swig_new_instance_method(_Box2D.b2Contact___GetNext)
    __GetFixtureA = _swig_new_instance_method(_Box2D.b2Contact___GetFixtureA)
    __GetChildIndexA = _swig_new_instance_method(_Box2D.b2Contact___GetChildIndexA)
    __GetFixtureB = _swig_new_instance_method(_Box2D.b2Contact___GetFixtureB)
    __GetChildIndexB = _swig_new_instance_method(_Box2D.b2Contact___GetChildIndexB)
    __SetFriction = _swig_new_instance_method(_Box2D.b2Contact___SetFriction)
    __GetFriction = _swig_new_instance_method(_Box2D.b2Contact___GetFriction)
    ResetFriction = _swig_new_instance_method(_Box2D.b2Contact_ResetFriction)
    __SetRestitution = _swig_new_instance_method(_Box2D.b2Contact___SetRestitution)
    __GetRestitution = _swig_new_instance_method(_Box2D.b2Contact___GetRestitution)
    ResetRestitution = _swig_new_instance_method(_Box2D.b2Contact_ResetRestitution)
    __SetTangentSpeed = _swig_new_instance_method(_Box2D.b2Contact___SetTangentSpeed)
    __GetTangentSpeed = _swig_new_instance_method(_Box2D.b2Contact___GetTangentSpeed)
    Evaluate = _swig_new_instance_method(_Box2D.b2Contact_Evaluate)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Contact___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __GetWorldManifold(self):
        ret=b2WorldManifold()
        self.__GetWorldManifold_internal(ret)
        return ret

    # Read-write properties
    enabled = property(__IsEnabled, __SetEnabled)

    # Read-only
    next = property(__GetNext, None)
    fixtureB = property(__GetFixtureB, None)
    fixtureA = property(__GetFixtureA, None)
    manifold = property(__GetManifold, None)
    childIndexA = property(__GetChildIndexA, None)
    childIndexB = property(__GetChildIndexB, None)
    worldManifold = property(__GetWorldManifold, None)
    touching = property(__IsTouching, None)
    friction = property(__GetFriction, __SetFriction)
    restitution = property(__GetRestitution, __SetRestitution)
    tangentSpeed = property(__GetTangentSpeed, __SetTangentSpeed)



# Register b2Contact in _Box2D:
_Box2D.b2Contact_swigregister(b2Contact)

e_wheelJoint = _Box2D.e_wheelJoint

e_ropeJoint = _Box2D.e_ropeJoint

class b2Jacobian(object):
    r"""Proxy of C++ b2Jacobian class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    linear = property(_Box2D.b2Jacobian_linear_get, _Box2D.b2Jacobian_linear_set, doc=r"""linear : b2Vec2""")
    angularA = property(_Box2D.b2Jacobian_angularA_get, _Box2D.b2Jacobian_angularA_set, doc=r"""angularA : float32""")
    angularB = property(_Box2D.b2Jacobian_angularB_get, _Box2D.b2Jacobian_angularB_set, doc=r"""angularB : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Jacobian___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2Jacobian_swiginit(self,_Box2D.new_b2Jacobian())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Jacobian

# Register b2Jacobian in _Box2D:
_Box2D.b2Jacobian_swigregister(b2Jacobian)

class b2JointEdge(object):
    r"""A joint edge is used to connect bodies and joints together in a joint graph where each body is a node and each joint is an edge. A joint edge belongs to a doubly linked list maintained in each attached body. Each joint has two joint nodes, one for each attached body."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    other = property(_Box2D.b2JointEdge_other_get, _Box2D.b2JointEdge_other_set, doc=r"""other : p.b2Body""")
    joint = property(_Box2D.b2JointEdge_joint_get, _Box2D.b2JointEdge_joint_set, doc=r"""joint : p.b2Joint""")
    prev = property(_Box2D.b2JointEdge_prev_get, _Box2D.b2JointEdge_prev_set, doc=r"""prev : p.b2JointEdge""")
    next = property(_Box2D.b2JointEdge_next_get, _Box2D.b2JointEdge_next_set, doc=r"""next : p.b2JointEdge""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2JointEdge___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2JointEdge_swiginit(self,_Box2D.new_b2JointEdge())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2JointEdge

# Register b2JointEdge in _Box2D:
_Box2D.b2JointEdge_swigregister(b2JointEdge)

class b2JointDef(object):
    r"""Joint definitions are used to construct joints."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2JointDef_swiginit(self,_Box2D.new_b2JointDef())
        _init_kwargs(self, **kwargs)


    type = property(_Box2D.b2JointDef_type_get, _Box2D.b2JointDef_type_set, doc=r"""type : b2JointType""")
    bodyA = property(_Box2D.b2JointDef_bodyA_get, _Box2D.b2JointDef_bodyA_set, doc=r"""bodyA : p.b2Body""")
    bodyB = property(_Box2D.b2JointDef_bodyB_get, _Box2D.b2JointDef_bodyB_set, doc=r"""bodyB : p.b2Body""")
    collideConnected = property(_Box2D.b2JointDef_collideConnected_get, _Box2D.b2JointDef_collideConnected_set, doc=r"""collideConnected : bool""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2JointDef___hash__)

    def __repr__(self):
        return _format_repr(self) 

    __GetUserData = _swig_new_instance_method(_Box2D.b2JointDef___GetUserData)
    __SetUserData = _swig_new_instance_method(_Box2D.b2JointDef___SetUserData)
    ClearUserData = _swig_new_instance_method(_Box2D.b2JointDef_ClearUserData)

    userData = property(__GetUserData, __SetUserData)
    def __del__(self):
        self.ClearUserData()


    def to_kwargs(self):
        """
        Returns a dictionary representing this joint definition
        """
        def is_prop(attr):
            try:
                is_property = isinstance(getattr(cls, attr), property)
            except AttributeError:
                return False

            return is_property and attr not in skip_props

        skip_props = ['anchor', 'anchorA', 'anchorB', 'axis']
        cls = type(self)
        return {attr: getattr(self, attr)
                for attr in dir(self)
                if is_prop(attr)
                }

    __swig_destroy__ = _Box2D.delete_b2JointDef

# Register b2JointDef in _Box2D:
_Box2D.b2JointDef_swigregister(b2JointDef)

class b2Joint(object):
    r"""The base joint class. Joints are used to constraint two bodies together in various fashions. Some joints also feature limits and motors."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __GetType = _swig_new_instance_method(_Box2D.b2Joint___GetType)
    __GetBodyA = _swig_new_instance_method(_Box2D.b2Joint___GetBodyA)
    __GetBodyB = _swig_new_instance_method(_Box2D.b2Joint___GetBodyB)
    __GetAnchorA = _swig_new_instance_method(_Box2D.b2Joint___GetAnchorA)
    __GetAnchorB = _swig_new_instance_method(_Box2D.b2Joint___GetAnchorB)
    GetReactionForce = _swig_new_instance_method(_Box2D.b2Joint_GetReactionForce)
    GetReactionTorque = _swig_new_instance_method(_Box2D.b2Joint_GetReactionTorque)
    __GetNext = _swig_new_instance_method(_Box2D.b2Joint___GetNext)
    __IsActive = _swig_new_instance_method(_Box2D.b2Joint___IsActive)
    __GetCollideConnected = _swig_new_instance_method(_Box2D.b2Joint___GetCollideConnected)
    Dump = _swig_new_instance_method(_Box2D.b2Joint_Dump)
    ShiftOrigin = _swig_new_instance_method(_Box2D.b2Joint_ShiftOrigin)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2Joint___hash__)

    def __repr__(self):
        return _format_repr(self) 

    __GetUserData = _swig_new_instance_method(_Box2D.b2Joint___GetUserData)
    __SetUserData = _swig_new_instance_method(_Box2D.b2Joint___SetUserData)
    ClearUserData = _swig_new_instance_method(_Box2D.b2Joint_ClearUserData)

    userData = property(__GetUserData, __SetUserData)


    __eq__ = b2JointCompare
    __ne__ = lambda self,other: not b2JointCompare(self,other)

    # Read-only
    next = property(__GetNext, None)
    bodyA = property(__GetBodyA, None)
    bodyB = property(__GetBodyB, None)
    type = property(__GetType, None)
    active = property(__IsActive, None)
    anchorB = property(__GetAnchorB, None)
    anchorA = property(__GetAnchorA, None)
    collideConnected = property(__GetCollideConnected, None)

    def getAsType(self):
        """
        Backward compatibility
        """
        return self


# Register b2Joint in _Box2D:
_Box2D.b2Joint_swigregister(b2Joint)

class b2DistanceJointDef(b2JointDef):
    r"""
    Distance joint definition. This requires defining an anchor point on both bodies and the non-zero length of the distance joint. The definition uses local anchor points so that the initial configuration can violate the constraint slightly. This helps when saving and loading a game. 
    WARNING: 
    Do not use a zero or short length.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2DistanceJointDef_swiginit(self,_Box2D.new_b2DistanceJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        if 'localAnchorA' in kwargs and 'localAnchorB' in kwargs and 'length' not in kwargs:
            self.__update_length()


    Initialize = _swig_new_instance_method(_Box2D.b2DistanceJointDef_Initialize)
    localAnchorA = property(_Box2D.b2DistanceJointDef_localAnchorA_get, _Box2D.b2DistanceJointDef_localAnchorA_set, doc=r"""localAnchorA : b2Vec2""")
    localAnchorB = property(_Box2D.b2DistanceJointDef_localAnchorB_get, _Box2D.b2DistanceJointDef_localAnchorB_set, doc=r"""localAnchorB : b2Vec2""")
    length = property(_Box2D.b2DistanceJointDef_length_get, _Box2D.b2DistanceJointDef_length_set, doc=r"""length : float32""")
    frequencyHz = property(_Box2D.b2DistanceJointDef_frequencyHz_get, _Box2D.b2DistanceJointDef_frequencyHz_set, doc=r"""frequencyHz : float32""")
    dampingRatio = property(_Box2D.b2DistanceJointDef_dampingRatio_get, _Box2D.b2DistanceJointDef_dampingRatio_set, doc=r"""dampingRatio : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2DistanceJointDef___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __update_length(self):
        if self.bodyA and self.bodyB:
            d = self.anchorB - self.anchorA
            self.length = d.length
    def __set_anchorA(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.__update_length()
    def __set_anchorB(self, value):
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
        self.__update_length()
    def __get_anchorA(self):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        return self.bodyA.GetWorldPoint(self.localAnchorA)
    def __get_anchorB(self):
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        return self.bodyB.GetWorldPoint(self.localAnchorB)

    anchorA = property(__get_anchorA, __set_anchorA, 
            doc="""Body A's anchor in world coordinates.
                Getting the property depends on both bodyA and localAnchorA.
                Setting the property requires that bodyA be set.""")
    anchorB = property(__get_anchorB, __set_anchorB, 
            doc="""Body B's anchor in world coordinates.
                Getting the property depends on both bodyB and localAnchorB.
                Setting the property requires that bodyB be set.""")

    __swig_destroy__ = _Box2D.delete_b2DistanceJointDef

# Register b2DistanceJointDef in _Box2D:
_Box2D.b2DistanceJointDef_swigregister(b2DistanceJointDef)

class b2DistanceJoint(b2Joint):
    r"""A distance joint constrains two points on two bodies to remain at a fixed distance from each other. You can view this as a massless, rigid rod."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    GetLocalAnchorA = _swig_new_instance_method(_Box2D.b2DistanceJoint_GetLocalAnchorA)
    GetLocalAnchorB = _swig_new_instance_method(_Box2D.b2DistanceJoint_GetLocalAnchorB)
    __SetLength = _swig_new_instance_method(_Box2D.b2DistanceJoint___SetLength)
    __GetLength = _swig_new_instance_method(_Box2D.b2DistanceJoint___GetLength)
    __SetFrequency = _swig_new_instance_method(_Box2D.b2DistanceJoint___SetFrequency)
    __GetFrequency = _swig_new_instance_method(_Box2D.b2DistanceJoint___GetFrequency)
    __SetDampingRatio = _swig_new_instance_method(_Box2D.b2DistanceJoint___SetDampingRatio)
    __GetDampingRatio = _swig_new_instance_method(_Box2D.b2DistanceJoint___GetDampingRatio)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2DistanceJoint___hash__)

    def __repr__(self):
        return _format_repr(self) 



            # Read-write properties
    length = property(__GetLength, __SetLength)
    frequency = property(__GetFrequency, __SetFrequency)
    dampingRatio = property(__GetDampingRatio, __SetDampingRatio)


    __swig_destroy__ = _Box2D.delete_b2DistanceJoint

# Register b2DistanceJoint in _Box2D:
_Box2D.b2DistanceJoint_swigregister(b2DistanceJoint)

class b2FrictionJointDef(b2JointDef):
    r"""Friction joint definition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2FrictionJointDef_swiginit(self,_Box2D.new_b2FrictionJointDef())
        _init_jointdef_kwargs(self, **kwargs)


    Initialize = _swig_new_instance_method(_Box2D.b2FrictionJointDef_Initialize)
    localAnchorA = property(_Box2D.b2FrictionJointDef_localAnchorA_get, _Box2D.b2FrictionJointDef_localAnchorA_set, doc=r"""localAnchorA : b2Vec2""")
    localAnchorB = property(_Box2D.b2FrictionJointDef_localAnchorB_get, _Box2D.b2FrictionJointDef_localAnchorB_set, doc=r"""localAnchorB : b2Vec2""")
    maxForce = property(_Box2D.b2FrictionJointDef_maxForce_get, _Box2D.b2FrictionJointDef_maxForce_set, doc=r"""maxForce : float32""")
    maxTorque = property(_Box2D.b2FrictionJointDef_maxTorque_get, _Box2D.b2FrictionJointDef_maxTorque_set, doc=r"""maxTorque : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2FrictionJointDef___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __set_anchor(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise ValueError('Neither body was set; unable to get world point.')

    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")

    __swig_destroy__ = _Box2D.delete_b2FrictionJointDef

# Register b2FrictionJointDef in _Box2D:
_Box2D.b2FrictionJointDef_swigregister(b2FrictionJointDef)

class b2FrictionJoint(b2Joint):
    r"""Friction joint. This is used for top-down friction. It provides 2D translational friction and angular friction."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    GetLocalAnchorA = _swig_new_instance_method(_Box2D.b2FrictionJoint_GetLocalAnchorA)
    GetLocalAnchorB = _swig_new_instance_method(_Box2D.b2FrictionJoint_GetLocalAnchorB)
    __SetMaxForce = _swig_new_instance_method(_Box2D.b2FrictionJoint___SetMaxForce)
    __GetMaxForce = _swig_new_instance_method(_Box2D.b2FrictionJoint___GetMaxForce)
    __SetMaxTorque = _swig_new_instance_method(_Box2D.b2FrictionJoint___SetMaxTorque)
    __GetMaxTorque = _swig_new_instance_method(_Box2D.b2FrictionJoint___GetMaxTorque)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2FrictionJoint___hash__)

    def __repr__(self):
        return _format_repr(self) 


            # Read-write properties
    maxForce = property(__GetMaxForce, __SetMaxForce)
    maxTorque = property(__GetMaxTorque, __SetMaxTorque)

    __swig_destroy__ = _Box2D.delete_b2FrictionJoint

# Register b2FrictionJoint in _Box2D:
_Box2D.b2FrictionJoint_swigregister(b2FrictionJoint)

class b2GearJointDef(b2JointDef):
    r"""Gear joint definition. This definition requires two existing revolute or prismatic joints (any combination will work). The provided joints must attach a dynamic body to a static body."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2GearJointDef_swiginit(self,_Box2D.new_b2GearJointDef())
        _init_kwargs(self, **kwargs)


    joint1 = property(_Box2D.b2GearJointDef_joint1_get, _Box2D.b2GearJointDef_joint1_set, doc=r"""joint1 : p.b2Joint""")
    joint2 = property(_Box2D.b2GearJointDef_joint2_get, _Box2D.b2GearJointDef_joint2_set, doc=r"""joint2 : p.b2Joint""")
    ratio = property(_Box2D.b2GearJointDef_ratio_get, _Box2D.b2GearJointDef_ratio_set, doc=r"""ratio : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2GearJointDef___hash__)

    def __repr__(self):
        return _format_repr(self) 

    __swig_destroy__ = _Box2D.delete_b2GearJointDef

# Register b2GearJointDef in _Box2D:
_Box2D.b2GearJointDef_swigregister(b2GearJointDef)

class b2GearJoint(b2Joint):
    r"""
    A gear joint is used to connect two joints together. Either joint can be a revolute or prismatic joint. You specify a gear ratio to bind the motions together: coordinate1 + ratio * coordinate2 = constant The ratio can be negative or positive. If one joint is a revolute joint and the other joint is a prismatic joint, then the ratio will have units of length or units of 1/length. 
    WARNING: 
    The revolute and prismatic joints must be attached to fixed bodies (which must be body1 on those joints).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    GetJoint1 = _swig_new_instance_method(_Box2D.b2GearJoint_GetJoint1)
    GetJoint2 = _swig_new_instance_method(_Box2D.b2GearJoint_GetJoint2)
    __SetRatio = _swig_new_instance_method(_Box2D.b2GearJoint___SetRatio)
    __GetRatio = _swig_new_instance_method(_Box2D.b2GearJoint___GetRatio)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2GearJoint___hash__)

    def __repr__(self):
        return _format_repr(self) 


            # Read-write properties
    ratio = property(__GetRatio, __SetRatio)


    __swig_destroy__ = _Box2D.delete_b2GearJoint

# Register b2GearJoint in _Box2D:
_Box2D.b2GearJoint_swigregister(b2GearJoint)

class b2MotorJointDef(b2JointDef):
    r"""Proxy of C++ b2MotorJointDef class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, bodyA=None, bodyB=None, **kwargs):
        _Box2D.b2MotorJointDef_swiginit(self,_Box2D.new_b2MotorJointDef())
        _init_jointdef_kwargs(self, bodyA=bodyA, bodyB=bodyB, **kwargs)
        if bodyA is not None and bodyB is not None:
            if not kwargs:
                self.Initialize(bodyA, bodyB)


    Initialize = _swig_new_instance_method(_Box2D.b2MotorJointDef_Initialize)
    linearOffset = property(_Box2D.b2MotorJointDef_linearOffset_get, _Box2D.b2MotorJointDef_linearOffset_set, doc=r"""linearOffset : b2Vec2""")
    angularOffset = property(_Box2D.b2MotorJointDef_angularOffset_get, _Box2D.b2MotorJointDef_angularOffset_set, doc=r"""angularOffset : float32""")
    maxForce = property(_Box2D.b2MotorJointDef_maxForce_get, _Box2D.b2MotorJointDef_maxForce_set, doc=r"""maxForce : float32""")
    maxTorque = property(_Box2D.b2MotorJointDef_maxTorque_get, _Box2D.b2MotorJointDef_maxTorque_set, doc=r"""maxTorque : float32""")
    correctionFactor = property(_Box2D.b2MotorJointDef_correctionFactor_get, _Box2D.b2MotorJointDef_correctionFactor_set, doc=r"""correctionFactor : float32""")



    __swig_destroy__ = _Box2D.delete_b2MotorJointDef

# Register b2MotorJointDef in _Box2D:
_Box2D.b2MotorJointDef_swigregister(b2MotorJointDef)

class b2MotorJoint(b2Joint):
    r"""Proxy of C++ b2MotorJoint class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __SetLinearOffset = _swig_new_instance_method(_Box2D.b2MotorJoint___SetLinearOffset)
    __GetLinearOffset = _swig_new_instance_method(_Box2D.b2MotorJoint___GetLinearOffset)
    __SetAngularOffset = _swig_new_instance_method(_Box2D.b2MotorJoint___SetAngularOffset)
    __GetAngularOffset = _swig_new_instance_method(_Box2D.b2MotorJoint___GetAngularOffset)
    __SetMaxForce = _swig_new_instance_method(_Box2D.b2MotorJoint___SetMaxForce)
    __GetMaxForce = _swig_new_instance_method(_Box2D.b2MotorJoint___GetMaxForce)
    __SetMaxTorque = _swig_new_instance_method(_Box2D.b2MotorJoint___SetMaxTorque)
    __GetMaxTorque = _swig_new_instance_method(_Box2D.b2MotorJoint___GetMaxTorque)

            # Read-write properties
    maxForce = property(__GetMaxForce, __SetMaxForce)
    maxTorque = property(__GetMaxTorque, __SetMaxTorque)
    linearOffset = property(__GetLinearOffset, __SetLinearOffset)
    angularOffset = property(__GetAngularOffset, __SetAngularOffset) 

    __swig_destroy__ = _Box2D.delete_b2MotorJoint

# Register b2MotorJoint in _Box2D:
_Box2D.b2MotorJoint_swigregister(b2MotorJoint)

class b2MouseJointDef(b2JointDef):
    r"""Mouse joint definition. This requires a world target point, tuning parameters, and the time step."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2MouseJointDef_swiginit(self,_Box2D.new_b2MouseJointDef())
        _init_kwargs(self, **kwargs)


    target = property(_Box2D.b2MouseJointDef_target_get, _Box2D.b2MouseJointDef_target_set, doc=r"""target : b2Vec2""")
    maxForce = property(_Box2D.b2MouseJointDef_maxForce_get, _Box2D.b2MouseJointDef_maxForce_set, doc=r"""maxForce : float32""")
    frequencyHz = property(_Box2D.b2MouseJointDef_frequencyHz_get, _Box2D.b2MouseJointDef_frequencyHz_set, doc=r"""frequencyHz : float32""")
    dampingRatio = property(_Box2D.b2MouseJointDef_dampingRatio_get, _Box2D.b2MouseJointDef_dampingRatio_set, doc=r"""dampingRatio : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2MouseJointDef___hash__)

    def __repr__(self):
        return _format_repr(self) 

    __swig_destroy__ = _Box2D.delete_b2MouseJointDef

# Register b2MouseJointDef in _Box2D:
_Box2D.b2MouseJointDef_swigregister(b2MouseJointDef)

class b2MouseJoint(b2Joint):
    r"""A mouse joint is used to make a point on a body track a specified world point. This a soft constraint with a maximum force. This allows the constraint to stretch and without applying huge forces. NOTE: this joint is not documented in the manual because it was developed to be used in the testbed. If you want to learn how to use the mouse joint, look at the testbed."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __SetTarget = _swig_new_instance_method(_Box2D.b2MouseJoint___SetTarget)
    __GetTarget = _swig_new_instance_method(_Box2D.b2MouseJoint___GetTarget)
    __SetMaxForce = _swig_new_instance_method(_Box2D.b2MouseJoint___SetMaxForce)
    __GetMaxForce = _swig_new_instance_method(_Box2D.b2MouseJoint___GetMaxForce)
    __SetFrequency = _swig_new_instance_method(_Box2D.b2MouseJoint___SetFrequency)
    __GetFrequency = _swig_new_instance_method(_Box2D.b2MouseJoint___GetFrequency)
    __SetDampingRatio = _swig_new_instance_method(_Box2D.b2MouseJoint___SetDampingRatio)
    __GetDampingRatio = _swig_new_instance_method(_Box2D.b2MouseJoint___GetDampingRatio)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2MouseJoint___hash__)

    def __repr__(self):
        return _format_repr(self) 



            # Read-write properties
    maxForce = property(__GetMaxForce, __SetMaxForce)
    frequency = property(__GetFrequency, __SetFrequency)
    dampingRatio = property(__GetDampingRatio, __SetDampingRatio)
    target = property(__GetTarget, __SetTarget)


    __swig_destroy__ = _Box2D.delete_b2MouseJoint

# Register b2MouseJoint in _Box2D:
_Box2D.b2MouseJoint_swigregister(b2MouseJoint)

class b2PrismaticJointDef(b2JointDef):
    r"""
    Prismatic joint definition. This requires defining a line of motion using an axis and an anchor point. The definition uses local anchor points and a local axis so that the initial configuration can violate the constraint slightly. The joint translation is zero when the local anchor points coincide in world space. Using local anchors and a local axis helps when saving and loading a game. 
    WARNING: 
    at least one body should by dynamic with a non-fixed rotation.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2PrismaticJointDef_swiginit(self,_Box2D.new_b2PrismaticJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        if self.bodyA and self.bodyB and 'referenceAngle' not in kwargs:
            self.referenceAngle = self.bodyB.angle - self.bodyA.angle


    Initialize = _swig_new_instance_method(_Box2D.b2PrismaticJointDef_Initialize)
    localAnchorA = property(_Box2D.b2PrismaticJointDef_localAnchorA_get, _Box2D.b2PrismaticJointDef_localAnchorA_set, doc=r"""localAnchorA : b2Vec2""")
    localAnchorB = property(_Box2D.b2PrismaticJointDef_localAnchorB_get, _Box2D.b2PrismaticJointDef_localAnchorB_set, doc=r"""localAnchorB : b2Vec2""")
    localAxisA = property(_Box2D.b2PrismaticJointDef_localAxisA_get, _Box2D.b2PrismaticJointDef_localAxisA_set, doc=r"""localAxisA : b2Vec2""")
    referenceAngle = property(_Box2D.b2PrismaticJointDef_referenceAngle_get, _Box2D.b2PrismaticJointDef_referenceAngle_set, doc=r"""referenceAngle : float32""")
    enableLimit = property(_Box2D.b2PrismaticJointDef_enableLimit_get, _Box2D.b2PrismaticJointDef_enableLimit_set, doc=r"""enableLimit : bool""")
    lowerTranslation = property(_Box2D.b2PrismaticJointDef_lowerTranslation_get, _Box2D.b2PrismaticJointDef_lowerTranslation_set, doc=r"""lowerTranslation : float32""")
    upperTranslation = property(_Box2D.b2PrismaticJointDef_upperTranslation_get, _Box2D.b2PrismaticJointDef_upperTranslation_set, doc=r"""upperTranslation : float32""")
    enableMotor = property(_Box2D.b2PrismaticJointDef_enableMotor_get, _Box2D.b2PrismaticJointDef_enableMotor_set, doc=r"""enableMotor : bool""")
    maxMotorForce = property(_Box2D.b2PrismaticJointDef_maxMotorForce_get, _Box2D.b2PrismaticJointDef_maxMotorForce_set, doc=r"""maxMotorForce : float32""")
    motorSpeed = property(_Box2D.b2PrismaticJointDef_motorSpeed_get, _Box2D.b2PrismaticJointDef_motorSpeed_set, doc=r"""motorSpeed : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2PrismaticJointDef___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __set_anchor(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise ValueError('Neither body was set; unable to get world point.')
    def __set_axis(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        self.localAxisA=self.bodyA.GetLocalVector(value)
    def __get_axis(self):
        if not self.bodyA:
            raise ValueError('Body A unset; unable to get world vector.')
        return self.bodyA.GetWorldVector(self.localAxisA)

    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")
    axis = property(__get_axis, __set_axis, 
            doc="""The world translation axis on bodyA.
                Getting the property depends on bodyA and localAxisA.
                Setting the property requires that bodyA be set.""")

    __swig_destroy__ = _Box2D.delete_b2PrismaticJointDef

# Register b2PrismaticJointDef in _Box2D:
_Box2D.b2PrismaticJointDef_swigregister(b2PrismaticJointDef)

class b2PrismaticJoint(b2Joint):
    r"""A prismatic joint. This joint provides one degree of freedom: translation along an axis fixed in body1. Relative rotation is prevented. You can use a joint limit to restrict the range of motion and a joint motor to drive the motion or to model joint friction."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    GetLocalAnchorA = _swig_new_instance_method(_Box2D.b2PrismaticJoint_GetLocalAnchorA)
    GetLocalAnchorB = _swig_new_instance_method(_Box2D.b2PrismaticJoint_GetLocalAnchorB)
    GetLocalAxisA = _swig_new_instance_method(_Box2D.b2PrismaticJoint_GetLocalAxisA)
    GetReferenceAngle = _swig_new_instance_method(_Box2D.b2PrismaticJoint_GetReferenceAngle)
    __GetJointTranslation = _swig_new_instance_method(_Box2D.b2PrismaticJoint___GetJointTranslation)
    __GetJointSpeed = _swig_new_instance_method(_Box2D.b2PrismaticJoint___GetJointSpeed)
    __IsLimitEnabled = _swig_new_instance_method(_Box2D.b2PrismaticJoint___IsLimitEnabled)
    __EnableLimit = _swig_new_instance_method(_Box2D.b2PrismaticJoint___EnableLimit)
    __GetLowerLimit = _swig_new_instance_method(_Box2D.b2PrismaticJoint___GetLowerLimit)
    __GetUpperLimit = _swig_new_instance_method(_Box2D.b2PrismaticJoint___GetUpperLimit)
    SetLimits = _swig_new_instance_method(_Box2D.b2PrismaticJoint_SetLimits)
    __IsMotorEnabled = _swig_new_instance_method(_Box2D.b2PrismaticJoint___IsMotorEnabled)
    __EnableMotor = _swig_new_instance_method(_Box2D.b2PrismaticJoint___EnableMotor)
    __SetMotorSpeed = _swig_new_instance_method(_Box2D.b2PrismaticJoint___SetMotorSpeed)
    __GetMotorSpeed = _swig_new_instance_method(_Box2D.b2PrismaticJoint___GetMotorSpeed)
    __SetMaxMotorForce = _swig_new_instance_method(_Box2D.b2PrismaticJoint___SetMaxMotorForce)
    __GetMaxMotorForce = _swig_new_instance_method(_Box2D.b2PrismaticJoint___GetMaxMotorForce)
    GetMotorForce = _swig_new_instance_method(_Box2D.b2PrismaticJoint_GetMotorForce)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2PrismaticJoint___hash__)

    def __repr__(self):
        return _format_repr(self) 



            # Read-write properties
    motorSpeed = property(__GetMotorSpeed, __SetMotorSpeed)
    motorEnabled = property(__IsMotorEnabled, __EnableMotor)
    limitEnabled = property(__IsLimitEnabled, __EnableLimit)
    upperLimit = property(__GetUpperLimit, lambda self, v: self.SetLimits(self.lowerLimit, v))
    lowerLimit = property(__GetLowerLimit, lambda self, v: self.SetLimits(v, self.upperLimit))
    limits = property(lambda self: (self.lowerLimit, self.upperLimit), lambda self, v: self.SetLimits(*v) )
    maxMotorForce = property(__GetMaxMotorForce, __SetMaxMotorForce)

    # Read-only
    translation = property(__GetJointTranslation, None)
    speed = property(__GetJointSpeed, None)


    __swig_destroy__ = _Box2D.delete_b2PrismaticJoint

# Register b2PrismaticJoint in _Box2D:
_Box2D.b2PrismaticJoint_swigregister(b2PrismaticJoint)

class b2PulleyJointDef(b2JointDef):
    r"""Pulley joint definition. This requires two ground anchors, two dynamic body anchor points, max lengths for each side, and a pulley ratio."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2PulleyJointDef_swiginit(self,_Box2D.new_b2PulleyJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        self.__init_pulley__(**kwargs)

    def __init_pulley__(self, anchorA=None, anchorB=None, lengthA=None, lengthB=None, groundAnchorA=None, groundAnchorB=None, maxLengthA=None, maxLengthB=None, ratio=None, **kwargs):
        lengthA_set, lengthB_set = False, False
        if anchorA is not None or anchorB is not None:
    # Some undoing -- if the user specified the length, we might
    # have overwritten it, so reset it.
            if lengthA is not None:
                self.lengthA = lengthA
                lengthA_set = True
            if lengthB is not None:
                self.lengthB = lengthB
                lengthB_set = True

        if anchorA is not None and groundAnchorA is not None and lengthA is None:
            d1 = self.anchorA - self.groundAnchorA
            self.lengthA = d1.length
            lengthA_set = True

        if anchorB is not None and groundAnchorB is not None and lengthB is None:
            d2 = self.anchorB - self.groundAnchorB
            self.lengthB = d2.length
            lengthB_set=True

        if ratio is not None:
    # Ratio too small?
            assert(self.ratio > globals()['b2_epsilon'])
            if lengthA_set and lengthB_set and maxLengthA is None and maxLengthB is None:
                C = self.lengthA + self.ratio * self.lengthB
                self.maxLengthA = C - self.ratio * b2_minPulleyLength
                self.maxLengthB = (C - b2_minPulleyLength) / self.ratio


    Initialize = _swig_new_instance_method(_Box2D.b2PulleyJointDef_Initialize)
    groundAnchorA = property(_Box2D.b2PulleyJointDef_groundAnchorA_get, _Box2D.b2PulleyJointDef_groundAnchorA_set, doc=r"""groundAnchorA : b2Vec2""")
    groundAnchorB = property(_Box2D.b2PulleyJointDef_groundAnchorB_get, _Box2D.b2PulleyJointDef_groundAnchorB_set, doc=r"""groundAnchorB : b2Vec2""")
    localAnchorA = property(_Box2D.b2PulleyJointDef_localAnchorA_get, _Box2D.b2PulleyJointDef_localAnchorA_set, doc=r"""localAnchorA : b2Vec2""")
    localAnchorB = property(_Box2D.b2PulleyJointDef_localAnchorB_get, _Box2D.b2PulleyJointDef_localAnchorB_set, doc=r"""localAnchorB : b2Vec2""")
    lengthA = property(_Box2D.b2PulleyJointDef_lengthA_get, _Box2D.b2PulleyJointDef_lengthA_set, doc=r"""lengthA : float32""")
    lengthB = property(_Box2D.b2PulleyJointDef_lengthB_get, _Box2D.b2PulleyJointDef_lengthB_set, doc=r"""lengthB : float32""")
    ratio = property(_Box2D.b2PulleyJointDef_ratio_get, _Box2D.b2PulleyJointDef_ratio_set, doc=r"""ratio : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2PulleyJointDef___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __update_length(self):
        if self.bodyA:
            d1 = self.anchorA - self.groundAnchorA
            self.lengthA = d1.length
        if self.bodyB:
            d1 = self.anchorB - self.groundAnchorB
            self.lengthB = d1.length
    def __set_anchorA(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.__update_length()
    def __set_anchorB(self, value):
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
        self.__update_length()
    def __get_anchorA(self):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        return self.bodyA.GetWorldPoint(self.localAnchorA)
    def __get_anchorB(self):
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        return self.bodyB.GetWorldPoint(self.localAnchorB)

    anchorA = property(__get_anchorA, __set_anchorA, 
            doc="""Body A's anchor in world coordinates.
                Getting the property depends on both bodyA and localAnchorA.
                Setting the property requires that bodyA be set.""")
    anchorB = property(__get_anchorB, __set_anchorB, 
            doc="""Body B's anchor in world coordinates.
                Getting the property depends on both bodyB and localAnchorB.
                Setting the property requires that bodyB be set.""")

    __swig_destroy__ = _Box2D.delete_b2PulleyJointDef

# Register b2PulleyJointDef in _Box2D:
_Box2D.b2PulleyJointDef_swigregister(b2PulleyJointDef)
b2_minPulleyLength = b2Globals.b2_minPulleyLength

class b2PulleyJoint(b2Joint):
    r"""The pulley joint is connected to two bodies and two fixed ground points. The pulley supports a ratio such that: length1 + ratio * length2 <= constant Yes, the force transmitted is scaled by the ratio. The pulley also enforces a maximum length limit on both sides. This is useful to prevent one side of the pulley hitting the top."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __GetGroundAnchorA = _swig_new_instance_method(_Box2D.b2PulleyJoint___GetGroundAnchorA)
    __GetGroundAnchorB = _swig_new_instance_method(_Box2D.b2PulleyJoint___GetGroundAnchorB)
    __GetLengthA = _swig_new_instance_method(_Box2D.b2PulleyJoint___GetLengthA)
    __GetLengthB = _swig_new_instance_method(_Box2D.b2PulleyJoint___GetLengthB)
    __GetRatio = _swig_new_instance_method(_Box2D.b2PulleyJoint___GetRatio)
    GetCurrentLengthA = _swig_new_instance_method(_Box2D.b2PulleyJoint_GetCurrentLengthA)
    GetCurrentLengthB = _swig_new_instance_method(_Box2D.b2PulleyJoint_GetCurrentLengthB)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2PulleyJoint___hash__)

    def __repr__(self):
        return _format_repr(self) 



            # Read-only
    groundAnchorB = property(__GetGroundAnchorB, None)
    groundAnchorA = property(__GetGroundAnchorA, None)
    ratio = property(__GetRatio, None)
    lengthB = length2 = property(__GetLengthB, None)
    lengthA = length1 = property(__GetLengthA, None)


    __swig_destroy__ = _Box2D.delete_b2PulleyJoint

# Register b2PulleyJoint in _Box2D:
_Box2D.b2PulleyJoint_swigregister(b2PulleyJoint)

class b2RevoluteJointDef(b2JointDef):
    r"""Revolute joint definition. This requires defining an anchor point where the bodies are joined. The definition uses local anchor points so that the initial configuration can violate the constraint slightly. You also need to specify the initial relative angle for joint limits. This helps when saving and loading a game. The local anchor points are measured from the body's origin rather than the center of mass because: 1. you might not know where the center of mass will be. 2. if you add/remove shapes from a body and recompute the mass, the joints will be broken."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2RevoluteJointDef_swiginit(self,_Box2D.new_b2RevoluteJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        if self.bodyA and self.bodyB and 'referenceAngle' not in kwargs:
            self.referenceAngle = self.bodyB.angle - self.bodyA.angle


    Initialize = _swig_new_instance_method(_Box2D.b2RevoluteJointDef_Initialize)
    localAnchorA = property(_Box2D.b2RevoluteJointDef_localAnchorA_get, _Box2D.b2RevoluteJointDef_localAnchorA_set, doc=r"""localAnchorA : b2Vec2""")
    localAnchorB = property(_Box2D.b2RevoluteJointDef_localAnchorB_get, _Box2D.b2RevoluteJointDef_localAnchorB_set, doc=r"""localAnchorB : b2Vec2""")
    referenceAngle = property(_Box2D.b2RevoluteJointDef_referenceAngle_get, _Box2D.b2RevoluteJointDef_referenceAngle_set, doc=r"""referenceAngle : float32""")
    enableLimit = property(_Box2D.b2RevoluteJointDef_enableLimit_get, _Box2D.b2RevoluteJointDef_enableLimit_set, doc=r"""enableLimit : bool""")
    lowerAngle = property(_Box2D.b2RevoluteJointDef_lowerAngle_get, _Box2D.b2RevoluteJointDef_lowerAngle_set, doc=r"""lowerAngle : float32""")
    upperAngle = property(_Box2D.b2RevoluteJointDef_upperAngle_get, _Box2D.b2RevoluteJointDef_upperAngle_set, doc=r"""upperAngle : float32""")
    enableMotor = property(_Box2D.b2RevoluteJointDef_enableMotor_get, _Box2D.b2RevoluteJointDef_enableMotor_set, doc=r"""enableMotor : bool""")
    motorSpeed = property(_Box2D.b2RevoluteJointDef_motorSpeed_get, _Box2D.b2RevoluteJointDef_motorSpeed_set, doc=r"""motorSpeed : float32""")
    maxMotorTorque = property(_Box2D.b2RevoluteJointDef_maxMotorTorque_get, _Box2D.b2RevoluteJointDef_maxMotorTorque_set, doc=r"""maxMotorTorque : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2RevoluteJointDef___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __set_anchor(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise ValueError('Neither body was set; unable to get world point.')
    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")

    __swig_destroy__ = _Box2D.delete_b2RevoluteJointDef

# Register b2RevoluteJointDef in _Box2D:
_Box2D.b2RevoluteJointDef_swigregister(b2RevoluteJointDef)

class b2RevoluteJoint(b2Joint):
    r"""A revolute joint constrains two bodies to share a common point while they are free to rotate about the point. The relative rotation about the shared point is the joint angle. You can limit the relative rotation with a joint limit that specifies a lower and upper angle. You can use a motor to drive the relative rotation about the shared point. A maximum motor torque is provided so that infinite forces are not generated."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    GetLocalAnchorA = _swig_new_instance_method(_Box2D.b2RevoluteJoint_GetLocalAnchorA)
    GetLocalAnchorB = _swig_new_instance_method(_Box2D.b2RevoluteJoint_GetLocalAnchorB)
    GetReferenceAngle = _swig_new_instance_method(_Box2D.b2RevoluteJoint_GetReferenceAngle)
    __GetJointAngle = _swig_new_instance_method(_Box2D.b2RevoluteJoint___GetJointAngle)
    __GetJointSpeed = _swig_new_instance_method(_Box2D.b2RevoluteJoint___GetJointSpeed)
    __IsLimitEnabled = _swig_new_instance_method(_Box2D.b2RevoluteJoint___IsLimitEnabled)
    __EnableLimit = _swig_new_instance_method(_Box2D.b2RevoluteJoint___EnableLimit)
    __GetLowerLimit = _swig_new_instance_method(_Box2D.b2RevoluteJoint___GetLowerLimit)
    __GetUpperLimit = _swig_new_instance_method(_Box2D.b2RevoluteJoint___GetUpperLimit)
    SetLimits = _swig_new_instance_method(_Box2D.b2RevoluteJoint_SetLimits)
    __IsMotorEnabled = _swig_new_instance_method(_Box2D.b2RevoluteJoint___IsMotorEnabled)
    __EnableMotor = _swig_new_instance_method(_Box2D.b2RevoluteJoint___EnableMotor)
    __SetMotorSpeed = _swig_new_instance_method(_Box2D.b2RevoluteJoint___SetMotorSpeed)
    __GetMotorSpeed = _swig_new_instance_method(_Box2D.b2RevoluteJoint___GetMotorSpeed)
    __SetMaxMotorTorque = _swig_new_instance_method(_Box2D.b2RevoluteJoint___SetMaxMotorTorque)
    GetMaxMotorTorque = _swig_new_instance_method(_Box2D.b2RevoluteJoint_GetMaxMotorTorque)
    GetMotorTorque = _swig_new_instance_method(_Box2D.b2RevoluteJoint_GetMotorTorque)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2RevoluteJoint___hash__)

    def __repr__(self):
        return _format_repr(self) 



            # Read-write properties
    motorSpeed = property(__GetMotorSpeed, __SetMotorSpeed)
    upperLimit = property(__GetUpperLimit, lambda self, v: self.SetLimits(self.lowerLimit, v))
    lowerLimit = property(__GetLowerLimit, lambda self, v: self.SetLimits(v, self.upperLimit))
    limits = property(lambda self: (self.lowerLimit, self.upperLimit), lambda self, v: self.SetLimits(*v) )
    motorEnabled = property(__IsMotorEnabled, __EnableMotor)
    limitEnabled = property(__IsLimitEnabled, __EnableLimit)

    # Read-only
    angle = property(__GetJointAngle, None)
    speed = property(__GetJointSpeed, None)

    # Write-only
    maxMotorTorque = property(None, __SetMaxMotorTorque)


    __swig_destroy__ = _Box2D.delete_b2RevoluteJoint

# Register b2RevoluteJoint in _Box2D:
_Box2D.b2RevoluteJoint_swigregister(b2RevoluteJoint)

class b2RopeJointDef(b2JointDef):
    r"""Rope joint definition. This requires two body anchor points and a maximum lengths. Note: by default the connected objects will not collide. see collideConnected in  b2JointDef."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2RopeJointDef_swiginit(self,_Box2D.new_b2RopeJointDef())
        _init_jointdef_kwargs(self, **kwargs)


    localAnchorA = property(_Box2D.b2RopeJointDef_localAnchorA_get, _Box2D.b2RopeJointDef_localAnchorA_set, doc=r"""localAnchorA : b2Vec2""")
    localAnchorB = property(_Box2D.b2RopeJointDef_localAnchorB_get, _Box2D.b2RopeJointDef_localAnchorB_set, doc=r"""localAnchorB : b2Vec2""")
    maxLength = property(_Box2D.b2RopeJointDef_maxLength_get, _Box2D.b2RopeJointDef_maxLength_set, doc=r"""maxLength : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2RopeJointDef___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __set_anchorA(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
    def __set_anchorB(self, value):
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchorA(self):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        return self.bodyA.GetWorldPoint(self.localAnchorA)
    def __get_anchorB(self):
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        return self.bodyB.GetWorldPoint(self.localAnchorB)

    anchorA = property(__get_anchorA, __set_anchorA, 
            doc="""Body A's anchor in world coordinates.
                Getting the property depends on both bodyA and localAnchorA.
                Setting the property requires that bodyA be set.""")
    anchorB = property(__get_anchorB, __set_anchorB, 
            doc="""Body B's anchor in world coordinates.
                Getting the property depends on both bodyB and localAnchorB.
                Setting the property requires that bodyB be set.""")

    __swig_destroy__ = _Box2D.delete_b2RopeJointDef

# Register b2RopeJointDef in _Box2D:
_Box2D.b2RopeJointDef_swigregister(b2RopeJointDef)

class b2RopeJoint(b2Joint):
    r"""A rope joint enforces a maximum distance between two points on two bodies. It has no other effect. Warning: if you attempt to change the maximum length during the simulation you will get some non-physical behavior. A model that would allow you to dynamically modify the length would have some sponginess, so I chose not to implement it that way. See  b2DistanceJointif you want to dynamically control length."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    GetLocalAnchorA = _swig_new_instance_method(_Box2D.b2RopeJoint_GetLocalAnchorA)
    GetLocalAnchorB = _swig_new_instance_method(_Box2D.b2RopeJoint_GetLocalAnchorB)
    SetMaxLength = _swig_new_instance_method(_Box2D.b2RopeJoint_SetMaxLength)
    __GetMaxLength = _swig_new_instance_method(_Box2D.b2RopeJoint___GetMaxLength)
    __GetLimitState = _swig_new_instance_method(_Box2D.b2RopeJoint___GetLimitState)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2RopeJoint___hash__)

    def __repr__(self):
        return _format_repr(self) 



            # Read-only properties
    maxLength = property(__GetMaxLength, None)
    limitState = property(__GetLimitState, None)

    # Read-write properties


    __swig_destroy__ = _Box2D.delete_b2RopeJoint

# Register b2RopeJoint in _Box2D:
_Box2D.b2RopeJoint_swigregister(b2RopeJoint)

class b2WeldJointDef(b2JointDef):
    r"""Weld joint definition. You need to specify local anchor points where they are attached and the relative body angle. The position of the anchor points is important for computing the reaction torque."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2WeldJointDef_swiginit(self,_Box2D.new_b2WeldJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        if self.bodyA and self.bodyB and 'referenceAngle' not in kwargs:
            self.referenceAngle = self.bodyB.angle - self.bodyA.angle


    Initialize = _swig_new_instance_method(_Box2D.b2WeldJointDef_Initialize)
    localAnchorA = property(_Box2D.b2WeldJointDef_localAnchorA_get, _Box2D.b2WeldJointDef_localAnchorA_set, doc=r"""localAnchorA : b2Vec2""")
    localAnchorB = property(_Box2D.b2WeldJointDef_localAnchorB_get, _Box2D.b2WeldJointDef_localAnchorB_set, doc=r"""localAnchorB : b2Vec2""")
    referenceAngle = property(_Box2D.b2WeldJointDef_referenceAngle_get, _Box2D.b2WeldJointDef_referenceAngle_set, doc=r"""referenceAngle : float32""")
    frequencyHz = property(_Box2D.b2WeldJointDef_frequencyHz_get, _Box2D.b2WeldJointDef_frequencyHz_set, doc=r"""frequencyHz : float32""")
    dampingRatio = property(_Box2D.b2WeldJointDef_dampingRatio_get, _Box2D.b2WeldJointDef_dampingRatio_set, doc=r"""dampingRatio : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2WeldJointDef___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __set_anchor(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise ValueError('Neither body was set; unable to get world point.')
    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")

    __swig_destroy__ = _Box2D.delete_b2WeldJointDef

# Register b2WeldJointDef in _Box2D:
_Box2D.b2WeldJointDef_swigregister(b2WeldJointDef)

class b2WeldJoint(b2Joint):
    r"""A weld joint essentially glues two bodies together. A weld joint may distort somewhat because the island constraint solver is approximate."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    GetLocalAnchorA = _swig_new_instance_method(_Box2D.b2WeldJoint_GetLocalAnchorA)
    GetLocalAnchorB = _swig_new_instance_method(_Box2D.b2WeldJoint_GetLocalAnchorB)
    GetReferenceAngle = _swig_new_instance_method(_Box2D.b2WeldJoint_GetReferenceAngle)
    SetFrequency = _swig_new_instance_method(_Box2D.b2WeldJoint_SetFrequency)
    GetFrequency = _swig_new_instance_method(_Box2D.b2WeldJoint_GetFrequency)
    SetDampingRatio = _swig_new_instance_method(_Box2D.b2WeldJoint_SetDampingRatio)
    GetDampingRatio = _swig_new_instance_method(_Box2D.b2WeldJoint_GetDampingRatio)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2WeldJoint___hash__)

    def __repr__(self):
        return _format_repr(self) 

    __swig_destroy__ = _Box2D.delete_b2WeldJoint

# Register b2WeldJoint in _Box2D:
_Box2D.b2WeldJoint_swigregister(b2WeldJoint)

class b2WheelJointDef(b2JointDef):
    r"""Line joint definition. This requires defining a line of motion using an axis and an anchor point. The definition uses local anchor points and a local axis so that the initial configuration can violate the constraint slightly. The joint translation is zero when the local anchor points coincide in world space. Using local anchors and a local axis helps when saving and loading a game."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2WheelJointDef_swiginit(self,_Box2D.new_b2WheelJointDef())
        _init_jointdef_kwargs(self, **kwargs)


    Initialize = _swig_new_instance_method(_Box2D.b2WheelJointDef_Initialize)
    localAnchorA = property(_Box2D.b2WheelJointDef_localAnchorA_get, _Box2D.b2WheelJointDef_localAnchorA_set, doc=r"""localAnchorA : b2Vec2""")
    localAnchorB = property(_Box2D.b2WheelJointDef_localAnchorB_get, _Box2D.b2WheelJointDef_localAnchorB_set, doc=r"""localAnchorB : b2Vec2""")
    localAxisA = property(_Box2D.b2WheelJointDef_localAxisA_get, _Box2D.b2WheelJointDef_localAxisA_set, doc=r"""localAxisA : b2Vec2""")
    enableMotor = property(_Box2D.b2WheelJointDef_enableMotor_get, _Box2D.b2WheelJointDef_enableMotor_set, doc=r"""enableMotor : bool""")
    maxMotorTorque = property(_Box2D.b2WheelJointDef_maxMotorTorque_get, _Box2D.b2WheelJointDef_maxMotorTorque_set, doc=r"""maxMotorTorque : float32""")
    motorSpeed = property(_Box2D.b2WheelJointDef_motorSpeed_get, _Box2D.b2WheelJointDef_motorSpeed_set, doc=r"""motorSpeed : float32""")
    frequencyHz = property(_Box2D.b2WheelJointDef_frequencyHz_get, _Box2D.b2WheelJointDef_frequencyHz_set, doc=r"""frequencyHz : float32""")
    dampingRatio = property(_Box2D.b2WheelJointDef_dampingRatio_get, _Box2D.b2WheelJointDef_dampingRatio_set, doc=r"""dampingRatio : float32""")

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2WheelJointDef___hash__)

    def __repr__(self):
        return _format_repr(self) 


    def __set_anchor(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise ValueError('Neither body was set; unable to get world point.')
    def __set_axis(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        self.localAxisA=self.bodyA.GetLocalVector(value)
    def __get_axis(self):
        if self.bodyA:
            return self.bodyA.GetWorldVector(self.localAxisA)
        raise ValueError('Body A unset; unable to get world vector.')

    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")
    axis = property(__get_axis, __set_axis, 
            doc="""The world translation axis on bodyA.
                Getting the property depends on bodyA and localAxisA.
                Setting the property requires that bodyA be set.""")

    __swig_destroy__ = _Box2D.delete_b2WheelJointDef

# Register b2WheelJointDef in _Box2D:
_Box2D.b2WheelJointDef_swigregister(b2WheelJointDef)

class b2WheelJoint(b2Joint):
    r"""A line joint. This joint provides two degrees of freedom: translation along an axis fixed in body1 and rotation in the plane. You can use a joint limit to restrict the range of motion and a joint motor to drive the rotation or to model rotational friction. This joint is designed for vehicle suspensions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    GetLocalAnchorA = _swig_new_instance_method(_Box2D.b2WheelJoint_GetLocalAnchorA)
    GetLocalAnchorB = _swig_new_instance_method(_Box2D.b2WheelJoint_GetLocalAnchorB)
    GetLocalAxisA = _swig_new_instance_method(_Box2D.b2WheelJoint_GetLocalAxisA)
    __GetJointTranslation = _swig_new_instance_method(_Box2D.b2WheelJoint___GetJointTranslation)
    __GetJointSpeed = _swig_new_instance_method(_Box2D.b2WheelJoint___GetJointSpeed)
    __IsMotorEnabled = _swig_new_instance_method(_Box2D.b2WheelJoint___IsMotorEnabled)
    __EnableMotor = _swig_new_instance_method(_Box2D.b2WheelJoint___EnableMotor)
    __SetMotorSpeed = _swig_new_instance_method(_Box2D.b2WheelJoint___SetMotorSpeed)
    __GetMotorSpeed = _swig_new_instance_method(_Box2D.b2WheelJoint___GetMotorSpeed)
    __SetMaxMotorTorque = _swig_new_instance_method(_Box2D.b2WheelJoint___SetMaxMotorTorque)
    __GetMaxMotorTorque = _swig_new_instance_method(_Box2D.b2WheelJoint___GetMaxMotorTorque)
    GetMotorTorque = _swig_new_instance_method(_Box2D.b2WheelJoint_GetMotorTorque)
    __SetSpringFrequencyHz = _swig_new_instance_method(_Box2D.b2WheelJoint___SetSpringFrequencyHz)
    __GetSpringFrequencyHz = _swig_new_instance_method(_Box2D.b2WheelJoint___GetSpringFrequencyHz)
    __SetSpringDampingRatio = _swig_new_instance_method(_Box2D.b2WheelJoint___SetSpringDampingRatio)
    __GetSpringDampingRatio = _swig_new_instance_method(_Box2D.b2WheelJoint___GetSpringDampingRatio)

    __dir__ = _dir_filter

    __hash__ = _swig_new_instance_method(_Box2D.b2WheelJoint___hash__)

    def __repr__(self):
        return _format_repr(self) 



            # Read-write properties
    motorSpeed = property(__GetMotorSpeed, __SetMotorSpeed)
    motorEnabled = property(__IsMotorEnabled, __EnableMotor)
    maxMotorTorque = property(__GetMaxMotorTorque, __SetMaxMotorTorque)
    springFrequencyHz = property(__GetSpringFrequencyHz , __SetSpringFrequencyHz)
    springDampingRatio = property(__GetSpringDampingRatio , __SetSpringDampingRatio)

    # Read-only
    speed = property(__GetJointSpeed, None)
    translation = property(__GetJointTranslation, None)


    __swig_destroy__ = _Box2D.delete_b2WheelJoint

# Register b2WheelJoint in _Box2D:
_Box2D.b2WheelJoint_swigregister(b2WheelJoint)


        # Backward-compatibility 
b2LoopShape = b2ChainShape

# Initialize the alternative namespace b2.*, and clean-up the
# dir listing of Box2D by removing *_swigregister.
#
# To see what this is, try import Box2D; print(dir(Box2D.b2))
from . import b2

s=None
to_remove=[]
for s in locals():
    if s.endswith('_swigregister'):
        to_remove.append(s)
    elif s!='b2' and s.startswith('b2'):
        if s[2]=='_': # Covers b2_*
            setattr(b2, s[3].lower() + s[4:], locals()[s])
        else: # The other b2*
            if s[3].isupper():
                setattr(b2, s[2:], locals()[s])
            else:
                setattr(b2, s[2].lower() + s[3:], locals()[s])
for s in to_remove:
    del locals()[s]

del s
del to_remove



